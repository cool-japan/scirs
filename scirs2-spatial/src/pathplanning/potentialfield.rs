//! Potential Field implementation for pathfinding with obstacles
//!
//! This module provides an implementation of the Potential Field algorithm
//! for path planning. It creates an artificial potential field where obstacles
//! generate repulsive forces and the goal generates an attractive force.
//! The agent moves along the gradient of this potential field to reach the goal.
//!
//! # Examples
//!
//! ```
//! use ndarray::Array1;
//! use scirs2_spatial::pathplanning::{PotentialFieldPlanner, PotentialConfig};
//!
//! // Create a configuration for the potential field planner
//! let config = PotentialConfig::new()
//!     .with_attractive_gain(1.0)
//!     .with_repulsive_gain(100.0)
//!     .with_influence_radius(5.0)
//!     .with_step_size(0.1)
//!     .with_max_iterations(1000);
//!
//! // Create a potential field planner
//! let mut planner = PotentialFieldPlanner::new_2d(config);
//!
//! // Add circular obstacles
//! planner.add_circular_obstacle([5.0, 5.0], 2.0);
//!
//! // Find a path from start to goal
//! let start = Array1::from_vec(vec![1.0, 1.0]);
//! let goal = Array1::from_vec(vec![9.0, 9.0]);
//!
//! // Plan the path
//! let path = planner.plan(&start, &goal);
//!
//! match path {
//!     Ok(Some(path)) => {
//!         println!("Path found with {} points", path.nodes.len());
//!         for point in &path.nodes {
//!             println!("  {:?}", point);
//!         }
//!     },
//!     Ok(None) => println!("No path found - stuck in local minimum"),
//!     Err(e) => println!("Error: {}", e),
//! }
//! ```

use ndarray::{Array1, ArrayView1};
use std::f64;

use crate::distance::EuclideanDistance;
use crate::error::{SpatialError, SpatialResult};
use crate::pathplanning::astar::Path;

/// Configuration for potential field path planning
#[derive(Debug, Clone)]
pub struct PotentialConfig {
    /// Gain of the attractive force generated by the goal
    pub attractive_gain: f64,
    /// Gain of the repulsive force generated by obstacles
    pub repulsive_gain: f64,
    /// Radius of influence for obstacle repulsion
    pub influence_radius: f64,
    /// Step size for each iteration
    pub step_size: f64,
    /// Maximum number of iterations
    pub max_iterations: usize,
    /// Goal threshold (distance at which to consider the goal reached)
    pub goal_threshold: f64,
    /// Threshold for detecting local minima (force magnitude)
    pub min_force_threshold: f64,
}

impl PotentialConfig {
    /// Create a new potential field configuration with default values
    pub fn new() -> Self {
        PotentialConfig {
            attractive_gain: 1.0,
            repulsive_gain: 100.0,
            influence_radius: 5.0,
            step_size: 0.1,
            max_iterations: 500,
            goal_threshold: 0.5,
            min_force_threshold: 0.01,
        }
    }

    /// Set the attractive force gain
    pub fn with_attractive_gain(mut self, gain: f64) -> Self {
        self.attractive_gain = gain;
        self
    }

    /// Set the repulsive force gain
    pub fn with_repulsive_gain(mut self, gain: f64) -> Self {
        self.repulsive_gain = gain;
        self
    }

    /// Set the obstacle influence radius
    pub fn with_influence_radius(mut self, radius: f64) -> Self {
        self.influence_radius = radius;
        self
    }

    /// Set the step size
    pub fn with_step_size(mut self, step: f64) -> Self {
        self.step_size = step;
        self
    }

    /// Set the maximum number of iterations
    pub fn with_max_iterations(mut self, iterations: usize) -> Self {
        self.max_iterations = iterations;
        self
    }

    /// Set the goal threshold
    pub fn with_goal_threshold(mut self, threshold: f64) -> Self {
        self.goal_threshold = threshold;
        self
    }

    /// Set the minimum force threshold for detecting local minima
    pub fn with_min_force_threshold(mut self, threshold: f64) -> Self {
        self.min_force_threshold = threshold;
        self
    }
}

impl Default for PotentialConfig {
    fn default() -> Self {
        PotentialConfig::new()
    }
}

/// Abstract obstacle representation for potential fields
#[derive(Debug, Clone)]
pub enum Obstacle {
    /// A circular obstacle (center, radius)
    Circle {
        /// Center of the circle
        center: Array1<f64>,
        /// Radius of the circle
        radius: f64,
    },
    /// A polygon obstacle (vertices)
    Polygon {
        /// Vertices of the polygon
        vertices: Vec<Array1<f64>>,
    },
    /// A custom obstacle with a distance function
    Custom {
        /// Function to compute the minimum distance to the obstacle
        distance_fn: Box<dyn Fn(&ArrayView1<f64>) -> f64>,
    },
}

impl Obstacle {
    /// Calculate minimum distance from a point to this obstacle
    pub fn distance(&self, point: &ArrayView1<f64>) -> f64 {
        match self {
            Obstacle::Circle { center, radius } => {
                let distance = euclidean_distance(*point, center.view());
                (distance - radius).max(0.0)
            }
            Obstacle::Polygon { vertices } => {
                if vertices.len() < 3 {
                    return f64::MAX; // Not a valid polygon
                }

                // For 2D polygons, we can use a more efficient method
                if point.len() == 2 && vertices[0].len() == 2 {
                    let p = [point[0], point[1]];

                    // Check if the point is inside the polygon
                    let mut inside = false;
                    let n = vertices.len();

                    for i in 0..n {
                        let v1 = [vertices[i][0], vertices[i][1]];
                        let v2 = [vertices[(i + 1) % n][0], vertices[(i + 1) % n][1]];

                        if ((v1[1] > p[1]) != (v2[1] > p[1]))
                            && (p[0] < v1[0] + (v2[0] - v1[0]) * (p[1] - v1[1]) / (v2[1] - v1[1]))
                        {
                            inside = !inside;
                        }
                    }

                    if inside {
                        return 0.0; // Inside the polygon
                    }

                    // Find minimum distance to any edge
                    let mut min_distance = f64::MAX;

                    for i in 0..n {
                        let v1 = &vertices[i];
                        let v2 = &vertices[(i + 1) % n];

                        // Distance to line segment
                        let a = point[0] - v1[0];
                        let b = point[1] - v1[1];
                        let c = v2[0] - v1[0];
                        let d = v2[1] - v1[1];

                        let dot = a * c + b * d;
                        let len_sq = c * c + d * d;
                        let param = if len_sq != 0.0 {
                            (dot / len_sq).clamp(0.0, 1.0)
                        } else {
                            0.0
                        };

                        let xx = v1[0] + param * c;
                        let yy = v1[1] + param * d;

                        let dx = point[0] - xx;
                        let dy = point[1] - yy;

                        let distance = (dx * dx + dy * dy).sqrt();

                        min_distance = min_distance.min(distance);
                    }

                    return min_distance;
                }

                // For higher dimensions, we need to compute distances differently
                // Just return distance to closest vertex for now
                vertices
                    .iter()
                    .map(|v| euclidean_distance(*point, v.view()))
                    .fold(f64::MAX, |a, b| a.min(b))
            }
            Obstacle::Custom { distance_fn } => distance_fn(point),
        }
    }
}

/// A planner that uses potential fields for path planning
#[derive(Debug)]
pub struct PotentialFieldPlanner {
    /// Configuration for the planner
    config: PotentialConfig,
    /// List of obstacles
    obstacles: Vec<Obstacle>,
    /// Dimension of the state space
    dimension: usize,
}

impl PotentialFieldPlanner {
    /// Create a new potential field planner with the given configuration and dimension
    pub fn new(config: PotentialConfig, dimension: usize) -> Self {
        PotentialFieldPlanner {
            config,
            obstacles: Vec::new(),
            dimension,
        }
    }

    /// Create a new 2D potential field planner
    pub fn new_2d(config: PotentialConfig) -> Self {
        Self::new(config, 2)
    }

    /// Add a circular obstacle
    pub fn add_circular_obstacle(&mut self, center: [f64; 2], radius: f64) -> &mut Self {
        let center_array = Array1::from_vec(center.to_vec());
        self.obstacles.push(Obstacle::Circle {
            center: center_array,
            radius,
        });
        self
    }

    /// Add a polygon obstacle (2D only)
    pub fn add_polygon_obstacle(&mut self, vertices: Vec<[f64; 2]>) -> &mut Self {
        let vertices_arrays = vertices
            .into_iter()
            .map(|v| Array1::from_vec(v.to_vec()))
            .collect::<Vec<_>>();

        self.obstacles.push(Obstacle::Polygon {
            vertices: vertices_arrays,
        });
        self
    }

    /// Add a custom obstacle with a distance function
    pub fn add_custom_obstacle<F>(&mut self, distance_fn: F) -> &mut Self
    where
        F: Fn(&ArrayView1<f64>) -> f64 + 'static,
    {
        self.obstacles.push(Obstacle::Custom {
            distance_fn: Box::new(distance_fn),
        });
        self
    }

    /// Calculate the attractive force towards the goal
    fn attractive_force(&self, position: &ArrayView1<f64>, goal: &ArrayView1<f64>) -> Array1<f64> {
        let distance = euclidean_distance(*position, *goal);

        let mut force = Array1::zeros(self.dimension);

        // No force if already at the goal
        if distance < 1e-6 {
            return force;
        }

        // Direction from position to goal
        for i in 0..self.dimension {
            force[i] = (goal[i] - position[i]) / distance;
        }

        // Scale by attractive gain
        force *= self.config.attractive_gain;

        force
    }

    /// Calculate the repulsive force away from obstacles
    fn repulsive_force(&self, position: &ArrayView1<f64>) -> Array1<f64> {
        let mut force = Array1::zeros(self.dimension);

        // Compute repulsive force from each obstacle
        for obstacle in &self.obstacles {
            let distance = obstacle.distance(position);

            // Only apply repulsive force within the influence radius
            if distance < self.config.influence_radius {
                match obstacle {
                    Obstacle::Circle { center, .. } => {
                        // Compute force direction (away from obstacle)
                        let mut direction = Array1::zeros(self.dimension);
                        let total_distance = euclidean_distance(*position, center.view());

                        if total_distance < 1e-6 {
                            // Random direction if exactly at obstacle center (extremely rare)
                            for i in 0..self.dimension {
                                direction[i] = rand::random::<f64>() * 2.0 - 1.0;
                            }
                            let norm = (direction.dot(&direction)).sqrt();
                            if norm > 0.0 {
                                direction /= norm;
                            }
                        } else {
                            // Direction from obstacle to position
                            for i in 0..self.dimension {
                                direction[i] = (position[i] - center[i]) / total_distance;
                            }
                        }

                        // Force magnitude - increases as distance decreases
                        let magnitude = self.config.repulsive_gain
                            * (1.0 / distance - 1.0 / self.config.influence_radius)
                            * (1.0 / (distance * distance));

                        // Add this obstacle's contribution
                        for i in 0..self.dimension {
                            force[i] += direction[i] * magnitude;
                        }
                    }
                    Obstacle::Polygon { vertices } => {
                        // For polygon obstacles, we need a more complex calculation
                        // Find the closest point on the polygon
                        if position.len() == 2 && vertices[0].len() == 2 {
                            let p = [position[0], position[1]];

                            // Check if the point is inside the polygon
                            let mut inside = false;
                            let n = vertices.len();

                            for i in 0..n {
                                let v1 = [vertices[i][0], vertices[i][1]];
                                let v2 = [vertices[(i + 1) % n][0], vertices[(i + 1) % n][1]];

                                if ((v1[1] > p[1]) != (v2[1] > p[1]))
                                    && (p[0]
                                        < v1[0]
                                            + (v2[0] - v1[0]) * (p[1] - v1[1]) / (v2[1] - v1[1]))
                                {
                                    inside = !inside;
                                }
                            }

                            if inside {
                                // If inside, push in the direction of the nearest edge
                                let mut min_distance = f64::MAX;
                                let mut nearest_normal = Array1::zeros(2);

                                for i in 0..n {
                                    let v1 = &vertices[i];
                                    let v2 = &vertices[(i + 1) % n];

                                    // Distance to line segment
                                    let a = position[0] - v1[0];
                                    let b = position[1] - v1[1];
                                    let c = v2[0] - v1[0];
                                    let d = v2[1] - v1[1];

                                    let dot = a * c + b * d;
                                    let len_sq = c * c + d * d;
                                    let param = if len_sq != 0.0 {
                                        (dot / len_sq).clamp(0.0, 1.0)
                                    } else {
                                        0.0
                                    };

                                    let xx = v1[0] + param * c;
                                    let yy = v1[1] + param * d;

                                    let dx = position[0] - xx;
                                    let dy = position[1] - yy;

                                    let distance = (dx * dx + dy * dy).sqrt();

                                    if distance < min_distance {
                                        min_distance = distance;

                                        // Calculate normal to the edge (perpendicular)
                                        let mut nx = -(v2[1] - v1[1]);
                                        let mut ny = v2[0] - v1[0];

                                        // Normalize
                                        let norm = (nx * nx + ny * ny).sqrt();
                                        if norm > 0.0 {
                                            nx /= norm;
                                            ny /= norm;
                                        }

                                        // Make sure it points outward (dot product with position - nearest point)
                                        let dot_product = nx * dx + ny * dy;
                                        if dot_product < 0.0 {
                                            nx = -nx;
                                            ny = -ny;
                                        }

                                        nearest_normal[0] = nx;
                                        nearest_normal[1] = ny;
                                    }
                                }

                                // Inside polygon - strong repulsive force
                                let magnitude = self.config.repulsive_gain * 10.0; // Much stronger when inside

                                for i in 0..self.dimension {
                                    force[i] += nearest_normal[i] * magnitude;
                                }
                            } else {
                                // Outside polygon - normal repulsive force based on distance
                                let mut min_distance = f64::MAX;
                                let mut nearest_point = Array1::zeros(2);

                                for i in 0..n {
                                    let v1 = &vertices[i];
                                    let v2 = &vertices[(i + 1) % n];

                                    // Distance to line segment
                                    let a = position[0] - v1[0];
                                    let b = position[1] - v1[1];
                                    let c = v2[0] - v1[0];
                                    let d = v2[1] - v1[1];

                                    let dot = a * c + b * d;
                                    let len_sq = c * c + d * d;
                                    let param = if len_sq != 0.0 {
                                        (dot / len_sq).clamp(0.0, 1.0)
                                    } else {
                                        0.0
                                    };

                                    let xx = v1[0] + param * c;
                                    let yy = v1[1] + param * d;

                                    let dx = position[0] - xx;
                                    let dy = position[1] - yy;

                                    let distance = (dx * dx + dy * dy).sqrt();

                                    if distance < min_distance {
                                        min_distance = distance;
                                        nearest_point[0] = xx;
                                        nearest_point[1] = yy;
                                    }
                                }

                                // Direction from obstacle to position
                                let mut direction = Array1::zeros(self.dimension);
                                for i in 0..self.dimension {
                                    direction[i] = position[i] - nearest_point[i];
                                }

                                let norm = (direction.dot(&direction)).sqrt();
                                if norm > 0.0 {
                                    direction /= norm;
                                }

                                // Force magnitude - increases as distance decreases
                                let magnitude = self.config.repulsive_gain
                                    * (1.0 / distance - 1.0 / self.config.influence_radius)
                                    * (1.0 / (distance * distance));

                                // Add this obstacle's contribution
                                for i in 0..self.dimension {
                                    force[i] += direction[i] * magnitude;
                                }
                            }
                        }
                    }
                    Obstacle::Custom { .. } => {
                        // For custom obstacles, we need to approximate the gradient
                        // This is a simple numerical gradient approximation
                        let h = 0.001; // Small step for numerical gradient
                        let mut gradient = Array1::zeros(self.dimension);

                        for i in 0..self.dimension {
                            let mut pos_plus = position.to_owned();
                            let mut pos_minus = position.to_owned();

                            pos_plus[i] += h;
                            pos_minus[i] -= h;

                            let dist_plus = obstacle.distance(&pos_plus.view());
                            let dist_minus = obstacle.distance(&pos_minus.view());

                            // Compute partial derivative
                            gradient[i] = (dist_plus - dist_minus) / (2.0 * h);
                        }

                        // Normalize gradient
                        let norm = (gradient.dot(&gradient)).sqrt();
                        if norm > 0.0 {
                            gradient /= norm;
                        }

                        // Force magnitude - increases as distance decreases
                        let magnitude = self.config.repulsive_gain
                            * (1.0 / distance - 1.0 / self.config.influence_radius)
                            * (1.0 / (distance * distance));

                        // Add this obstacle's contribution
                        for i in 0..self.dimension {
                            force[i] += gradient[i] * magnitude;
                        }
                    }
                }
            }
        }

        force
    }

    /// Calculate the total force at a given position
    fn total_force(&self, position: &ArrayView1<f64>, goal: &ArrayView1<f64>) -> Array1<f64> {
        let attractive = self.attractive_force(position, goal);
        let repulsive = self.repulsive_force(position);

        attractive + repulsive
    }

    /// Plan a path from start to goal
    pub fn plan(
        &self,
        start: &Array1<f64>,
        goal: &Array1<f64>,
    ) -> SpatialResult<Option<Path<Array1<f64>>>> {
        if start.len() != self.dimension || goal.len() != self.dimension {
            return Err(SpatialError::DimensionError(format!(
                "Start and goal dimensions must match planner dimension ({})",
                self.dimension
            )));
        }

        // Check if the goal is inside an obstacle
        for obstacle in &self.obstacles {
            if obstacle.distance(&goal.view()) < 1e-6 {
                return Err(SpatialError::ValueError(
                    "Goal position is inside an obstacle".to_string(),
                ));
            }
        }

        // Initialize path
        let mut path = Vec::new();
        path.push(start.clone());

        let mut current = start.clone();
        let mut total_distance = 0.0;

        for _ in 0..self.config.max_iterations {
            // Check if we've reached the goal
            let goal_distance = euclidean_distance(current.view(), goal.view());
            if goal_distance < self.config.goal_threshold {
                // Add goal and return
                path.push(goal.clone());
                total_distance += goal_distance;
                return Ok(Some(Path::new(path, total_distance)));
            }

            // Calculate force at current position
            let force = self.total_force(&current.view(), &goal.view());

            // Check for local minimum (very small force)
            let force_magnitude = (force.dot(&force)).sqrt();
            if force_magnitude < self.config.min_force_threshold {
                return Ok(None); // Stuck in local minimum
            }

            // Normalize force vector
            let direction = &force / force_magnitude;

            // Update position
            let mut next = current.clone();
            for i in 0..self.dimension {
                next[i] += direction[i] * self.config.step_size;
            }

            // Check if the next position is inside an obstacle
            let mut inside_obstacle = false;
            for obstacle in &self.obstacles {
                if obstacle.distance(&next.view()) < 1e-6 {
                    inside_obstacle = true;
                    break;
                }
            }

            // Skip this step if inside obstacle
            if inside_obstacle {
                continue;
            }

            // Add step distance to total
            let step_distance = euclidean_distance(current.view(), next.view());
            total_distance += step_distance;

            // Add to path if it's a significant step
            if step_distance > 1e-6 {
                path.push(next.clone());
            }

            // Update current position
            current = next;
        }

        // If we didn't reach the goal within max iterations, return the partial path
        Ok(Some(Path::new(path, total_distance)))
    }
}

/// A specialized 2D potential field planner with polygon obstacles
#[derive(Debug)]
pub struct PotentialField2DPlanner {
    /// The underlying potential field planner
    planner: PotentialFieldPlanner,
}

impl PotentialField2DPlanner {
    /// Create a new 2D potential field planner
    pub fn new(config: PotentialConfig) -> Self {
        PotentialField2DPlanner {
            planner: PotentialFieldPlanner::new_2d(config),
        }
    }

    /// Add a circular obstacle
    pub fn add_circular_obstacle(&mut self, center: [f64; 2], radius: f64) -> &mut Self {
        self.planner.add_circular_obstacle(center, radius);
        self
    }

    /// Add a polygon obstacle
    pub fn add_polygon_obstacle(&mut self, vertices: Vec<[f64; 2]>) -> &mut Self {
        self.planner.add_polygon_obstacle(vertices);
        self
    }

    /// Plan a path from start to goal
    pub fn plan(
        &self,
        start: [f64; 2],
        goal: [f64; 2],
    ) -> SpatialResult<Option<Path<Array1<f64>>>> {
        let start_array = Array1::from_vec(vec![start[0], start[1]]);
        let goal_array = Array1::from_vec(vec![goal[0], goal[1]]);

        self.planner.plan(&start_array, &goal_array)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;
    use ndarray::array;

    #[test]
    fn test_potential_config() {
        let config = PotentialConfig::new()
            .with_attractive_gain(2.0)
            .with_repulsive_gain(50.0)
            .with_influence_radius(3.0)
            .with_step_size(0.2)
            .with_max_iterations(200)
            .with_goal_threshold(0.3)
            .with_min_force_threshold(0.005);

        assert_eq!(config.attractive_gain, 2.0);
        assert_eq!(config.repulsive_gain, 50.0);
        assert_eq!(config.influence_radius, 3.0);
        assert_eq!(config.step_size, 0.2);
        assert_eq!(config.max_iterations, 200);
        assert_eq!(config.goal_threshold, 0.3);
        assert_eq!(config.min_force_threshold, 0.005);
    }

    #[test]
    fn test_circular_obstacle_distance() {
        let obstacle = Obstacle::Circle {
            center: array![5.0, 5.0],
            radius: 2.0,
        };

        // Point outside the circle
        let point1 = array![8.0, 5.0];
        assert_relative_eq!(obstacle.distance(&point1.view()), 1.0); // 3 - 2 = 1

        // Point on the circle
        let point2 = array![7.0, 5.0];
        assert_relative_eq!(obstacle.distance(&point2.view()), 0.0); // 2 - 2 = 0

        // Point inside the circle
        let point3 = array![6.0, 5.0];
        assert_relative_eq!(obstacle.distance(&point3.view()), 0.0); // Inside returns 0
    }

    #[test]
    fn test_polygon_obstacle_distance() {
        // Square obstacle from (2,2) to (4,4)
        let vertices = vec![
            array![2.0, 2.0],
            array![4.0, 2.0],
            array![4.0, 4.0],
            array![2.0, 4.0],
        ];

        let obstacle = Obstacle::Polygon { vertices };

        // Point outside the square
        let point1 = array![1.0, 3.0];
        assert_relative_eq!(obstacle.distance(&point1.view()), 1.0); // Distance to left side

        // Point on the square
        let point2 = array![2.0, 3.0];
        assert_relative_eq!(obstacle.distance(&point2.view()), 0.0); // On the edge

        // Point inside the square
        let point3 = array![3.0, 3.0];
        assert_relative_eq!(obstacle.distance(&point3.view()), 0.0); // Inside returns 0
    }

    #[test]
    fn test_simple_path() {
        let config = PotentialConfig::new()
            .with_attractive_gain(1.0)
            .with_repulsive_gain(100.0)
            .with_influence_radius(3.0)
            .with_step_size(0.2)
            .with_max_iterations(100);

        let mut planner = PotentialFieldPlanner::new_2d(config);

        // Add a circular obstacle
        planner.add_circular_obstacle([5.0, 5.0], 2.0);

        // Start and goal points that require going around the obstacle
        let start = array![1.0, 5.0];
        let goal = array![9.0, 5.0];

        let path = planner.plan(&start, &goal).unwrap();

        // There should be a path
        assert!(path.is_some());

        let path = path.unwrap();

        // Path should start at start and end near goal
        assert_eq!(path.nodes[0], start);

        let last = path.nodes.last().unwrap();
        let goal_distance = euclidean_distance(last.view(), goal.view());
        assert!(
            goal_distance < 0.5,
            "Last point {:?} should be near goal {:?}",
            last,
            goal
        );

        // Path should have reasonable number of points (not too few)
        assert!(path.nodes.len() > 5);

        // Ensure the path doesn't go through the obstacle
        for point in &path.nodes {
            let dx = point[0] - 5.0;
            let dy = point[1] - 5.0;
            let distance = (dx * dx + dy * dy).sqrt();

            assert!(
                distance > 1.95, // Allow a small epsilon
                "Path point {:?} goes through obstacle at (5,5) with radius 2.0",
                point
            );
        }
    }

    #[test]
    fn test_local_minimum() {
        // Create a configuration with very low step size to make it easier to get stuck
        let config = PotentialConfig::new()
            .with_attractive_gain(0.5)
            .with_repulsive_gain(200.0)
            .with_influence_radius(5.0)
            .with_step_size(0.05)
            .with_min_force_threshold(0.1) // Higher threshold to detect minima more easily
            .with_max_iterations(50);

        let mut planner = PotentialFieldPlanner::new_2d(config);

        // Create a U-shaped obstacle that can trap the algorithm
        planner.add_polygon_obstacle(vec![
            [3.0, 2.0],
            [7.0, 2.0], // Bottom of U
            [7.0, 7.0],
            [6.0, 7.0], // Right side of U
            [6.0, 3.0],
            [4.0, 3.0], // Inside of U
            [4.0, 7.0],
            [3.0, 7.0], // Left side of U
        ]);

        // Start inside the U, goal outside (requires going around)
        let start = array![5.0, 4.0];
        let goal = array![5.0, 9.0];

        let result = planner.plan(&start, &goal).unwrap();

        // The planner should get stuck in the local minimum
        assert!(
            result.is_none(),
            "Planner should get stuck in local minimum"
        );
    }

    #[test]
    fn test_2d_planner() {
        let config = PotentialConfig::new()
            .with_attractive_gain(1.0)
            .with_repulsive_gain(100.0)
            .with_step_size(0.1);

        let mut planner = PotentialField2DPlanner::new(config);

        // Add some obstacles
        planner.add_circular_obstacle([3.0, 3.0], 1.0);
        planner.add_polygon_obstacle(vec![[5.0, 5.0], [7.0, 5.0], [6.0, 7.0]]);

        // Plan a path
        let start = [1.0, 1.0];
        let goal = [8.0, 8.0];

        let path = planner.plan(start, goal).unwrap();

        // There should be a path
        assert!(path.is_some());

        let path = path.unwrap();

        // Path should start at start
        assert_relative_eq!(path.nodes[0][0], start[0], epsilon = 1e-5);
        assert_relative_eq!(path.nodes[0][1], start[1], epsilon = 1e-5);

        // Last point should be near goal
        let last = path.nodes.last().unwrap();
        let dx = last[0] - goal[0];
        let dy = last[1] - goal[1];
        let goal_distance = (dx * dx + dy * dy).sqrt();

        assert!(
            goal_distance < 0.5,
            "Last point {:?} should be near goal {:?}",
            last,
            goal
        );
    }
}
