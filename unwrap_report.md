# Unwrap() Usage Report

Total unwrap() calls and unsafe operations found: 3188

## Summary by Type

- Replace with ? operator or .ok_or(): 2091 occurrences
- Division without zero check - use safe_divide(): 760 occurrences
- Mathematical operation .sqrt() without validation: 121 occurrences
- Mathematical operation .ln() without validation: 116 occurrences
- Mathematical operation .powf( without validation: 70 occurrences
- Use .get() with proper bounds checking: 26 occurrences
- Handle array creation errors properly: 4 occurrences

## Detailed Findings


### benches/comprehensive_scipy_comparison.rs

6 issues found:

- Line 36: `let normal = Normal::new(mean, std).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 48: `let exp = Exponential::new(lambda).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 63: `let y = correlation * &x + (1.0 - correlation.powi(2)).sqrt() * noise;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 227: `let normal = distributions::Normal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 249: `let t_dist = distributions::StudentT::new(10.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 261: `let chi2 = distributions::ChiSquare::new(5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### benches/distributions.rs

16 issues found:

- Line 29: `let dist = norm(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 43: `let dist = t(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 58: `let dist = uniform(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `let dist = norm(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 100: `let dist = chi2(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 125: `let dist = norm(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 137: `let dist = uniform(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 149: `let dist = expon(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 161: `let dist = poisson(3.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 178: `let dist = norm(5.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `let dist = norm(5.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 189: `let dist = gamma(2.0, 3.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 194: `let dist = gamma(2.0, 3.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 200: `let dist = beta(2.0, 5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 215: `let dist = poisson(3.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 225: `let dist = binom(10, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### benches/statistical_tests.rs

1 issues found:

- Line 24: `let normal = Normal::new(mean, std).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/bartlett_test.rs

4 issues found:

- Line 22: `let (stat, p_value) = bartlett(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 53: `let (stat, p_value) = bartlett(&samples2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 78: `let (stat, p_value) = bartlett(&samples3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 96: `let mean = data.sum() / n;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/bernoulli_distribution.rs

3 issues found:

- Line 142: `100.0 * success_count as f64 / samples.len() as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 168: `println!("- Skewness = (1-2p) / âˆš(p(1-p))");`
  - **Fix**: Division without zero check - use safe_divide()
- Line 169: `println!("- Kurtosis = (1-6p(1-p)) / (p(1-p))");`
  - **Fix**: Division without zero check - use safe_divide()

### examples/binomial_distribution.rs

4 issues found:

- Line 175: `let mean = sum / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 181: `100.0 * count_5_or_more as f64 / samples.len() as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 205: `println!("- Skewness = (1-2p) / sqrt(n*p*(1-p))");`
  - **Fix**: Division without zero check - use safe_divide()
- Line 206: `println!("- Kurtosis = (1-6p(1-p)) / (n*p*(1-p))");`
  - **Fix**: Division without zero check - use safe_divide()

### examples/brown_forsythe_test.rs

7 issues found:

- Line 22: `let (stat, p_value) = brown_forsythe(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 41: `let (stat_bf, p_bf) = brown_forsythe(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 44: `let (stat_mean, p_mean) = levene(&samples, "mean", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 47: `let (stat_trim, p_trim) = levene(&samples, "trimmed", 0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 72: `let (stat_bf, p_bf) = brown_forsythe(&samples2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 73: `let (stat_mean, p_mean) = levene(&samples2, "mean", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 92: `let mean = data.sum() / n;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/circular_distributions.rs

12 issues found:

- Line 21: `let vm = vonmises(PI / 4.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 24: `let angles = [-PI, -PI / 2.0, 0.0, PI / 4.0, PI / 2.0, PI];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 42: `let samples = vm.rvs(10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 52: `let wc = wrapcauchy(0.0, 0.6).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 72: `let samples = wc.rvs(10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 82: `let vm1 = vonmises(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 83: `let vm2 = vonmises(0.0, 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 84: `let vm3 = vonmises(0.0, 20.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `let wc1 = wrapcauchy(0.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 86: `let wc2 = wrapcauchy(0.0, 0.7).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 110: `let vm = vonmises(0.0, kappa).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `let wc = wrapcauchy(0.0, gamma).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/dirichlet_distribution.rs

7 issues found:

- Line 14: `let uniform_dirichlet = multivariate::dirichlet(&alpha_uniform).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 20: `array![1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0],`
  - **Fix**: Division without zero check - use safe_divide()
- Line 40: `let concentrated_dirichlet = multivariate::dirichlet(&alpha_concentrated).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 59: `let asymmetric_dirichlet = multivariate::dirichlet(&alpha_asymmetric).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 83: `let samples = asymmetric_dirichlet.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `let samples = asymmetric_dirichlet.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 116: `let theoretical_mean = alpha_asymmetric.mapv(|a| a / alpha_sum);`
  - **Fix**: Division without zero check - use safe_divide()

### examples/distribution_characteristics.rs

17 issues found:

- Line 16: `let unimodal_result = mode(&multi_data.view(), ModeMethod::Unimodal).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 17: `let multimodal_result = mode(&multi_data.view(), ModeMethod::MultiModal).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 51: `let entropy_uniform = entropy(&uniform.view(), Some(2.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 52: `let entropy_less = entropy(&less_uniform.view(), Some(2.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 53: `let entropy_single = entropy(&single_value.view(), Some(2.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 70: `let kl_div = kl_divergence(&p.view(), &q.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 71: `let kl_div_reverse = kl_divergence(&q.view(), &p.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 72: `let cross_ent = cross_entropy(&p.view(), &q.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 92: `let _skew_sym = skew(&symmetric.view(), false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 93: `let _skew_right = skew(&right_skewed.view(), false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 94: `let _skew_left = skew(&left_skewed.view(), false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `let skew_ci_sym = skewness_ci(&symmetric.view(), false, None, Some(1000), Some(4...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 99: `skewness_ci(&right_skewed.view(), false, None, Some(1000), Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 100: `let skew_ci_left = skewness_ci(&left_skewed.view(), false, None, Some(1000), Som...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `kurtosis_ci(&platykurtic.view(), true, false, None, Some(1000), Some(42)).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 135: `kurtosis_ci(&mesokurtic.view(), true, false, None, Some(1000), Some(42)).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 137: `kurtosis_ci(&leptokurtic.view(), true, false, None, Some(1000), Some(42)).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/enhanced_regression.rs

11 issues found:

- Line 22: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 26: `let results = linear_regression(&x_simple.view(), &y_simple.view(), None).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 37: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 39: `let predictions = results.predict(&x_new.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 56: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 60: `let results_multi = linear_regression(&x_multi.view(), &y_multi.view(), None).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 65: `let (coeffs, residuals, rank, sv) = multilinear_regression(&x_multi.view(), &y_m...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 95: `let poly_coeffs = polyfit(&x_poly.view(), &y_poly.view(), 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 111: `let poly_results = linear_regression(&x_poly_design.view(), &y_poly.view(), None...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 128: `let x_pred = Array2::from_shape_vec((1, 3), vec![1.0, x_f64, x_f64.powi(2)]).unw...`
  - **Fix**: Handle array creation errors properly
- Line 129: `let y_pred = poly_results.predict(&x_pred.view()).unwrap()[0];`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/enhanced_ttests.rs

9 issues found:

- Line 26: `enhanced_ttest_1samp(&data.view(), null_mean, Alternative::TwoSided, "omit").unw...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 31: `enhanced_ttest_1samp(&data.view(), null_mean, Alternative::Greater, "omit").unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 35: `let less = enhanced_ttest_1samp(&data.view(), null_mean, Alternative::Less, "omi...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 57: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 68: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 84: `enhanced_ttest_rel(&before.view(), &after.view(), Alternative::TwoSided, "omit")...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 112: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 127: `enhanced_ttest_1samp(&data_with_nan.view(), 5.0, Alternative::TwoSided, "omit")....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 160: `let threshold = F::from(0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/friedman_test.rs

3 issues found:

- Line 22: `let (chi2, p_value) = friedman(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 52: `let (chi2, p_value) = friedman(&data2.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 82: `let (chi2, p_value) = friedman(&data3.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/geometric_distribution.rs

2 issues found:

- Line 144: `let mean = sum / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 150: `100.0 * count_large as f64 / samples.len() as f64`
  - **Fix**: Division without zero check - use safe_divide()

### examples/gini_coefficient.rs

3 issues found:

- Line 7: `let gini_equal = gini_coefficient(&equal_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 13: `let gini_unequal = gini_coefficient(&unequal_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 21: `let gini_income = gini_coefficient(&income_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/huber_regression.rs

12 issues found:

- Line 34: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 47: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 60: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 63: `let ols_result = scirs2_stats::linregress(&x_values.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 98: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 102: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 106: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 110: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 140: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 155: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 170: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 183: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/intraclass_correlation.rs

4 issues found:

- Line 21: `let (icc1, conf_int1) = icc(&data.view(), 1, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 30: `let (icc2, conf_int2) = icc(&data.view(), 2, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 39: `let (icc3, conf_int3) = icc(&data.view(), 3, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 56: `let (icc_poor, conf_int_poor) = icc(&data_poor.view(), 2, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/kendall_tau_correlation.rs

8 issues found:

- Line 10: `let tau = kendall_tau(&x.view(), &y.view(), "b").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 16: `let (tau, p_value) = kendallr(&x.view(), &y.view(), "b", "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 30: `let (tau2, p_value2) = kendallr(&x.view(), &y2.view(), "b", "two-sided").unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 36: `let (tau3, p_value3) = kendallr(&x.view(), &y3.view(), "b", "two-sided").unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 44: `kendallr(&x_ties.view(), &y_ties.view(), "b", "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 49: `let (_, p_greater) = kendallr(&x.view(), &y.view(), "b", "greater").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 50: `let (_, p_less) = kendallr(&x.view(), &y.view(), "b", "less").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 56: `let (tau_c, p_value_c) = kendallr(&x.view(), &y.view(), "c", "two-sided").unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/kolmogorov_smirnov_test.rs

9 issues found:

- Line 18: `let (stat, p_value) = ks_2samp(&sample1.view(), &sample2.view(), "two-sided").un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 35: `let (stat, p_value) = ks_2samp(&sample1.view(), &sample2.view(), "two-sided").un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 52: `let (stat, p_value) = ks_2samp(&sample1.view(), &sample2.view(), "less").unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 69: `let (stat, p_value) = ks_2samp(&sample1.view(), &sample2.view(), "greater").unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `let normal_dist = distributions::norm(0.0f64, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 86: `let normal_sample = normal_dist.rvs(20).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 89: `let uniform_dist = distributions::uniform(0.0f64, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 90: `let uniform_sample = uniform_dist.rvs(20).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 94: `ks_2samp(&normal_sample.view(), &uniform_sample.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/levene_test.rs

5 issues found:

- Line 24: `let (stat, p_value) = levene(&samples, "median", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 40: `let (stat, p_value) = levene(&samples, "mean", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 56: `let (stat, p_value) = levene(&samples, "trimmed", 0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 80: `let (stat, p_value) = levene(&samples2, "median", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 98: `let mean = data.sum() / n;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/logistic_distribution.rs

2 issues found:

- Line 175: `println!("- PDF: f(x) = e^(-z) / (scale Ã— (1 + e^(-z))Â²) where z = (x-loc)/scale...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 176: `println!("- CDF: F(x) = 1 / (1 + e^(-z))");`
  - **Fix**: Division without zero check - use safe_divide()

### examples/mann_whitney_u_test.rs

4 issues found:

- Line 16: `let (u, p_value) = mann_whitney(&males.view(), &females.view(), "two-sided", tru...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 24: `let (u, p_value) = mann_whitney(&females.view(), &males.view(), "less", true).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 32: `let (u, p_value) = mann_whitney(&males.view(), &females.view(), "two-sided", fal...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 40: `let (u, p_value) = mann_whitney(&males.view(), &females.view(), "greater", true)...`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/multinomial_distribution.rs

1 issues found:

- Line 66: `let sample_mean = sample_sum / num_samples as f64;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/multivariate_distributions.rs

7 issues found:

- Line 30: `let sample_mean = samples.mean_axis(Axis(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 37: `let sample_cov = centered.t().dot(&centered) / (n_samples as f64 - 1.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 61: `let t_sample_mean = t_samples.mean_axis(Axis(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 73: `t_var / normal_var`
  - **Fix**: Division without zero check - use safe_divide()
- Line 83: `println!("Ratio (t/normal): {:.4}", t_max / normal_max);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 89: `let mean = samples.mean_axis(Axis(0)).unwrap()[dim];`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `sum_sq / (n as f64 - 1.0)`
  - **Fix**: Division without zero check - use safe_divide()

### examples/multivariate_lognormal_distribution.rs

7 issues found:

- Line 101: `let corr_computed = cov_matrix[[0, 1]] / (cov_matrix[[0, 0]] * cov_matrix[[1, 1]...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 101: `let corr_computed = cov_matrix[[0, 1]] / (cov_matrix[[0, 0]] * cov_matrix[[1, 1]...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 131: `mean / n_samples as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 141: `values.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 145: `median[j] = (values[n_samples / 2 - 1] + values[n_samples / 2]) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 148: `median[j] = values[n_samples / 2];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 172: `cov / (n_samples as f64 - 1.0)`
  - **Fix**: Division without zero check - use safe_divide()

### examples/multivariate_t_distribution.rs

1 issues found:

- Line 70: `let sample_mean = samples.mean_axis(ndarray::Axis(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/pareto_distribution.rs

1 issues found:

- Line 136: `let mean = sum / 10.0;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/partial_correlation.rs

6 issues found:

- Line 11: `let z = Array2::from_shape_vec((11, 1), z1.to_vec()).unwrap();`
  - **Fix**: Handle array creation errors properly
- Line 14: `let pr = partial_corr(&x.view(), &y.view(), &z.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 18: `let (pr, p_value) = partial_corrr(&x.view(), &y.view(), &z.view(), "two-sided")....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 37: `partial_corrr(&x.view(), &y.view(), &z_multi.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 42: `let (_, p_greater) = partial_corrr(&x.view(), &y.view(), &z.view(), "greater").u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 43: `let (_, p_less) = partial_corrr(&x.view(), &y.view(), &z.view(), "less").unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/pearson_correlation.rs

10 issues found:

- Line 13: `let r1: f64 = pearson_r(&x1.view(), &y1.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 16: `let (r1_with_p, p1) = pearsonr(&x1.view(), &y1.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 38: `let r2: f64 = pearson_r(&x2.view(), &y2.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 39: `let (r2_with_p, p2) = pearsonr(&x2.view(), &y2.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 61: `let r3: f64 = pearson_r(&x3.view(), &y3.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 62: `let (r3_with_p, p3) = pearsonr(&x3.view(), &y3.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `let (r4_two, p4_two) = pearsonr(&x4.view(), &y4.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 88: `let (r4_greater, p4_greater) = pearsonr(&x4.view(), &y4.view(), "greater").unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 91: `let (r4_less, p4_less) = pearsonr(&x4.view(), &y4.view(), "less").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 115: `let (r5, p5) = pearsonr(&x5.view(), &y5.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/point_biserial_correlation.rs

6 issues found:

- Line 10: `let rpb = point_biserial(&binary.view(), &continuous.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 14: `let (rpb, p_value) = point_biserialr(&binary.view(), &continuous.view(), "two-si...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 27: `point_biserialr(&binary.view(), &continuous_weak.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 32: `let (_, p_greater) = point_biserialr(&binary.view(), &continuous.view(), "greate...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 33: `let (_, p_less) = point_biserialr(&binary.view(), &continuous.view(), "less").un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 41: `point_biserialr(&binary.view(), &continuous_neg.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/quantile_functions.rs

25 issues found:

- Line 19: `let median = quantile(&data_normal.view(), 0.5, QuantileInterpolation::Linear).u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 22: `let q1 = quantile(&data_normal.view(), 0.25, QuantileInterpolation::Linear).unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 25: `let q3 = quantile(&data_normal.view(), 0.75, QuantileInterpolation::Linear).unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 32: `quantile(&data_normal.view(), 0.4, QuantileInterpolation::Linear).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 36: `quantile(&data_normal.view(), 0.4, QuantileInterpolation::Lower).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 40: `quantile(&data_normal.view(), 0.4, QuantileInterpolation::Higher).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 44: `quantile(&data_normal.view(), 0.4, QuantileInterpolation::Nearest).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 48: `quantile(&data_normal.view(), 0.4, QuantileInterpolation::Midpoint).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 52: `quantile(&data_normal.view(), 0.4, QuantileInterpolation::Hazen).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 56: `quantile(&data_normal.view(), 0.4, QuantileInterpolation::Weibull).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 63: `percentile(&data_normal.view(), 25.0, QuantileInterpolation::Linear).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 67: `percentile(&data_normal.view(), 50.0, QuantileInterpolation::Linear).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 71: `percentile(&data_normal.view(), 75.0, QuantileInterpolation::Linear).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 75: `percentile(&data_normal.view(), 90.0, QuantileInterpolation::Linear).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 81: `quartiles(&data_normal.view(), QuantileInterpolation::Linear).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `quintiles(&data_normal.view(), QuantileInterpolation::Linear).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 89: `deciles(&data_normal.view(), QuantileInterpolation::Linear).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 100: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 114: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 127: `let mean = data_with_outlier.sum() / data_with_outlier.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 132: `/ (data_with_outlier.len() - 1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 138: `let win_mean_10 = winsorized_mean(&data_with_outlier.view(), 0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 139: `let win_var_10 = winsorized_variance(&data_with_outlier.view(), 0.1, 1).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 143: `let win_mean_20 = winsorized_mean(&data_with_outlier.view(), 0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 144: `let win_var_20 = winsorized_variance(&data_with_outlier.view(), 0.2, 1).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/ransac_regression.rs

10 issues found:

- Line 33: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 36: `let ols_result = scirs2_stats::linregress(&x_values.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 59: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 63: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 67: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 71: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 100: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 113: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 126: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 135: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/regression_summary.rs

2 issues found:

- Line 62: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 65: `let predictions = results.predict(&x_new.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/robust_regression.rs

15 issues found:

- Line 16: `let mut slopes = Vec::with_capacity(n * (n - 1) / 2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 24: `slopes.push(dy / dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 33: `let mid = slopes.len() / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 35: `(slopes[mid - 1] + slopes[mid]) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 43: `let x_median = x.iter().sum::<f64>() / n as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 44: `let y_median = y.iter().sum::<f64>() / n as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 56: `let x_mean = x.iter().sum::<f64>() / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 57: `let y_mean = y.iter().sum::<f64>() / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 69: `let slope = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 90: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `let slope = (y2 - y1) / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 185: `let new_slope = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 199: `epsilon / residual.abs()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 206: `let new_intercept = weighted_sum / weight_sum;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 285: `let x_val = j as f64 / 3.0;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/robust_regression_comparison.rs

21 issues found:

- Line 24: `let theilsen_result = theilslopes(&x_values.view(), &y.view(), None, None).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 38: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 53: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 58: `let ols_result = scirs2_stats::linregress(&x_values.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 101: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 109: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 136: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 149: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 162: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 175: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 225: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 238: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 250: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 262: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 274: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 300: `(((ols_slope - 2.0) / 2.0) * 100.0).abs()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 306: `(((theilsen_slope - 2.0) / 2.0) * 100.0).abs()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 312: `(((ransac_slope - 2.0) / 2.0) * 100.0).abs()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 318: `(((huber_slope - 2.0) / 2.0) * 100.0).abs()`
  - **Fix**: Division without zero check - use safe_divide()

### examples/robust_regression_demo.rs

4 issues found:

- Line 32: `let mse = results.residuals.mapv(|r| r * r).sum() / results.residuals.len() as f...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 83: `let y_mean = y.mean().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `let r_squared_theilsen = 1.0 - (ss_res / ss_tot);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 86: `let _mse_theilsen = ss_res / y.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/robust_regression_standalone.rs

43 issues found:

- Line 25: `let mut slopes = Vec::with_capacity(n * (n - 1) / 2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 33: `slopes.push(dy / dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 42: `let mid = slopes.len() / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 44: `(slopes[mid - 1] + slopes[mid]) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 52: `let x_median = x.iter().sum::<f64>() / n as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 53: `let y_median = y.iter().sum::<f64>() / n as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 58: `let sigma = 1.0 / (1.5 * n_float.sqrt());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 58: `let sigma = 1.0 / (1.5 * n_float.sqrt());`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 75: `let x_mean = x.iter().sum::<f64>() / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 76: `let y_mean = y.iter().sum::<f64>() / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 88: `let slope = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 104: `let r_squared = 1.0 - ss_residual / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 129: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 160: `let slope = (y2 - y1) / dx;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 201: `let y_mean = inlier_y.iter().sum::<f64>() / inlier_y.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 212: `1.0 - ss_residual / ss_total`
  - **Fix**: Division without zero check - use safe_divide()
- Line 257: `let new_slope = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 271: `epsilon / residual.abs()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 278: `let new_intercept = weighted_sum / weight_sum;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 293: `let y_mean = y.iter().sum::<f64>() / y.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 303: `let r_squared = 1.0 - ss_residual / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 368: `let x_val = x_min + (x_max - x_min) * (x_pos as f64 / 60.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 375: `if (xi - x_val).abs() < (x_max - x_min) / 60.0 * 0.8`
  - **Fix**: Division without zero check - use safe_divide()
- Line 475: `100.0 * ols_error / true_slope`
  - **Fix**: Division without zero check - use safe_divide()
- Line 480: `100.0 * theil_error / true_slope`
  - **Fix**: Division without zero check - use safe_divide()
- Line 485: `100.0 * ransac_error / true_slope`
  - **Fix**: Division without zero check - use safe_divide()
- Line 490: `100.0 * huber_error / true_slope`
  - **Fix**: Division without zero check - use safe_divide()
- Line 578: `100.0 * ols_error2 / true_slope2`
  - **Fix**: Division without zero check - use safe_divide()
- Line 583: `100.0 * theil_error2 / true_slope2`
  - **Fix**: Division without zero check - use safe_divide()
- Line 588: `100.0 * ransac_error2 / true_slope2`
  - **Fix**: Division without zero check - use safe_divide()
- Line 593: `100.0 * huber_error2 / true_slope2`
  - **Fix**: Division without zero check - use safe_divide()
- Line 681: `100.0 * ols_error3 / true_slope3`
  - **Fix**: Division without zero check - use safe_divide()
- Line 686: `100.0 * theil_error3 / true_slope3`
  - **Fix**: Division without zero check - use safe_divide()
- Line 691: `100.0 * ransac_error3 / true_slope3`
  - **Fix**: Division without zero check - use safe_divide()
- Line 696: `100.0 * huber_error3 / true_slope3`
  - **Fix**: Division without zero check - use safe_divide()
- Line 719: `(ols_error / true_slope + ols_error2 / true_slope2 + ols_error3 / true_slope3) *...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 720: `/ 3.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 729: `(theil_error / true_slope + theil_error2 / true_slope2 + theil_error3 / true_slo...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 731: `/ 3.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 740: `(ransac_error / true_slope + ransac_error2 / true_slope2 + ransac_error3 / true_...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 742: `/ 3.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 751: `(huber_error / true_slope + huber_error2 / true_slope2 + huber_error3 / true_slo...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 753: `/ 3.0`
  - **Fix**: Division without zero check - use safe_divide()

### examples/spearman_correlation.rs

7 issues found:

- Line 10: `let rho = spearman_r(&x.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 16: `let (rho, p_value) = spearmanr(&x.view(), &y.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 31: `let (rho2, p_value2) = spearmanr(&x.view(), &y2.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 37: `let (rho3, p_value3) = spearmanr(&x.view(), &y3.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 47: `let (_, p_greater) = spearmanr(&x.view(), &y.view(), "greater").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 48: `let (_, p_less) = spearmanr(&x.view(), &y.view(), "less").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 55: `let (rho4, p_value4) = spearmanr(&x.view(), &y4.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/stepwise_regression.rs

4 issues found:

- Line 16: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 44: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 77: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 110: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### examples/theilslopes_regression.rs

10 issues found:

- Line 18: `let result = theilslopes(&x.view(), &y.view(), None, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 21: `let ols_result = scirs2_stats::linregress(&x.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 47: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 51: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 55: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 59: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 98: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 110: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 119: `let x = min_x + (max_x - min_x) * i as f64 / 99.0;`
  - **Fix**: Division without zero check - use safe_divide()

### examples/wishart_distribution.rs

7 issues found:

- Line 15: `let wishart_identity = multivariate::wishart(scale_identity.clone(), df).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 43: `let wishart_correlated = multivariate::wishart(scale_correlated.clone(), df_corr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 80: `let samples = wishart_correlated.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 113: `let mvn = multivariate::multivariate_normal(true_mean, true_cov.clone()).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 115: `let data_samples = mvn.rvs(50).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 143: `let posterior = multivariate::wishart(posterior_scale, posterior_df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 144: `let posterior_samples = posterior.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/api_improvements.rs

3 issues found:

- Line 241: `assert_eq!(CorrelationMethod::from_str("pearson").unwrap(), CorrelationMethod::P...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 242: `assert_eq!(CorrelationMethod::from_str("spearman").unwrap(), CorrelationMethod::...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 243: `assert_eq!(CorrelationMethod::from_str("kendall").unwrap(), CorrelationMethod::K...`
  - **Fix**: Replace with ? operator or .ok_or()

### src/bayesian/conjugate.rs

22 issues found:

- Line 47: `self.alpha / (self.alpha + self.beta)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 53: `(self.alpha * self.beta) / (total * total * (total + 1.0))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 59: `Some((self.alpha - 1.0) / (self.alpha + self.beta - 2.0))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 73: `let alpha_level = (1.0 - confidence) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 119: `self.alpha / self.beta`
  - **Fix**: Division without zero check - use safe_divide()
- Line 124: `self.alpha / (self.beta * self.beta)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 130: `Some((self.alpha - 1.0) / self.beta)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 144: `let alpha_level = (1.0 - confidence) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 188: `let precision_prior = 1.0 / self.prior_variance;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 189: `let precision_data = n / self.data_variance;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 192: `let posterior_variance = 1.0 / precision_posterior;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 193: `let posterior_mean = (precision_prior * self.prior_mean + precision_data * data_...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 218: `let dist = Normal::new(self.prior_mean, self.prior_variance.sqrt())?;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 220: `let alpha_level = (1.0 - confidence) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 282: `&self.alpha / sum`
  - **Fix**: Division without zero check - use safe_divide()
- Line 290: `Some((&self.alpha - 1.0) / (sum - k))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 300: `mean.mapv(|p| p * (1.0 - p) / (sum + 1.0))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 341: `let mu_n = (self.lambda * self.mu0 + n * data_mean) / lambda_n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 342: `let alpha_n = self.alpha + n / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 343: `let beta_n = self.beta + 0.5 * ss + 0.5 * self.lambda * n * (data_mean - self.mu...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 360: `self.beta / (self.alpha - 1.0)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 365: `self.beta / (self.lambda * (self.alpha - 1.0))`
  - **Fix**: Division without zero check - use safe_divide()

### src/contingency/mod.rs

33 issues found:

- Line 92: `expected[[i, j]] = row_sums[i] * col_sums[j] / total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 108: `chi2 = chi2 + obs * (obs / exp).ln();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 108: `chi2 = chi2 + obs * (obs / exp).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 112: `chi2 = chi2 * F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 131: `diff = (diff.abs() - F::from(0.5).unwrap()).max(F::zero()) * diff.signum();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `chi2 = chi2 + diff * diff / exp;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 150: `let p_value = match crate::distributions::chi2(F::from(dof).unwrap(), F::zero(),...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 230: `(a * d) / (b * c)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 250: `let exp_a = row1_sum * col1_sum / total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 251: `let exp_b = row1_sum * col2_sum / total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 252: `let exp_c = row2_sum * col1_sum / total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 253: `let exp_d = row2_sum * col2_sum / total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 257: `let diff_a = (a - exp_a).abs() - F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 258: `let diff_b = (b - exp_b).abs() - F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 259: `let diff_c = (c - exp_c).abs() - F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 260: `let diff_d = (d - exp_d).abs() - F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 263: `diff_a * diff_a / exp_a`
  - **Fix**: Division without zero check - use safe_divide()
- Line 268: `diff_b * diff_b / exp_b`
  - **Fix**: Division without zero check - use safe_divide()
- Line 273: `diff_c * diff_c / exp_c`
  - **Fix**: Division without zero check - use safe_divide()
- Line 278: `diff_d * diff_d / exp_d`
  - **Fix**: Division without zero check - use safe_divide()
- Line 286: `(diff * diff) / F::from(4.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 391: `let min_dim = F::from((nrows - 1).min(ncols - 1)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 394: `let cramer_v = (chi2 / (total * min_dim)).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 394: `let cramer_v = (chi2 / (total * min_dim)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 477: `if (a - F::from(10.0).unwrap()).abs() < F::epsilon()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 478: `&& (b - F::from(90.0).unwrap()).abs() < F::epsilon()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 479: `&& (c - F::from(5.0).unwrap()).abs() < F::epsilon()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 480: `&& (d - F::from(195.0).unwrap()).abs() < F::epsilon()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 482: `return Ok(F::from(2.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 492: `let risk_exposed = a / exposed_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 501: `let risk_unexposed = c / unexposed_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 517: `Ok(risk_exposed / risk_unexposed)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 597: `Ok((a * d) / (b * c))`
  - **Fix**: Division without zero check - use safe_divide()

### src/correlation.rs

102 issues found:

- Line 89: `let corr = sum_xy / (sum_x2 * sum_y2).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 89: `let corr = sum_xy / (sum_x2 * sum_y2).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 196: `let avg_rank = F::from((i + j) as f64 / 2.0 + 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 302: `let _n0 = F::from(n * (n - 1) / 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 307: `let n1 = F::from(concordant + discordant + ties_x).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 308: `let n2 = F::from(concordant + discordant + ties_y).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 317: `F::from(concordant - discordant).unwrap() / (n1 * n2).sqrt()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 321: `let m = F::from(n.min(2)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 322: `(F::from(2.0).unwrap() * m * F::from(concordant - discordant).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 323: `/ (F::from(n).unwrap().powi(2) * (m - F::one()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 458: `let df = F::from(n - 2 - p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `if df <= F::from(2.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 481: `F::from(1e6).unwrap() // Very large positive value`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 483: `F::from(-1e6).unwrap() // Very large negative value`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 486: `pr * (df / (F::one() - pr * pr)).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 486: `pr * (df / (F::one() - pr * pr)).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 509: `F::from(2.0).unwrap() * (F::one() - student_t_cdf(t_stat.abs(), df))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 638: `let factor = aug[[j, i]] / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 652: `x[i] = (aug[[i, n]] - sum) / aug[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 746: `mean1 = mean1 / F::from(n1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 747: `mean0 = mean0 / F::from(n0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 753: `let n = F::from(binary.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 754: `let n1_f = F::from(n1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 755: `let n0_f = F::from(n0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 757: `let corr = ((mean1 - mean0) / std_y) * (n1_f * n0_f / (n * n)).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 757: `let corr = ((mean1 - mean0) / std_y) * (n1_f * n0_f / (n * n)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 833: `let df = F::from(n - 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 838: `F::from(1e6).unwrap() // Very large positive value`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 840: `F::from(-1e6).unwrap() // Very large negative value`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 843: `rpb * (df / (F::one() - rpb * rpb)).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 843: `rpb * (df / (F::one() - rpb * rpb)).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 866: `F::from(2.0).unwrap() * (F::one() - student_t_cdf(t_stat.abs(), df))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 970: `let corr = pearson_r(&x.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 976: `let corr = pearson_r(&x.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 982: `let corr = pearson_r(&x.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 992: `let corr = spearman_r(&x.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 998: `let corr = spearman_r(&x.view(), &y.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1008: `let corr = kendall_tau(&x.view(), &y.view(), "b").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1014: `let corr = kendall_tau(&x.view(), &y.view(), "b").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1021: `let corr = kendall_tau(&x.view(), &y.view(), "b").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1037: `let corr_mat = corrcoef(&data.view(), "pearson").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1060: `let (r, p) = pearsonr(&x.view(), &y.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1068: `let (_, p) = pearsonr(&x_small.view(), &y_small.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1162: `let df = F::from(n - 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1165: `let t_stat = r_abs * (df / (F::one() - r_abs * r_abs)).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1165: `let t_stat = r_abs * (df / (F::one() - r_abs * r_abs)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1187: `F::from(2.0).unwrap() * (F::one() - student_t_cdf(t_stat, df))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1196: `let t_f64 = <f64 as NumCast>::from(t).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1197: `let df_f64 = <f64 as NumCast>::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1200: `let x = df_f64 / (df_f64 + t_f64 * t_f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1205: `0.5 * beta_cdf(x, df_f64 / 2.0, 0.5)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1207: `1.0 - 0.5 * beta_cdf(x, df_f64 / 2.0, 0.5)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1210: `F::from(p).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1223: `if x <= (a / (a + b)) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1227: `beta_x / beta_full`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1232: `1.0 - beta_x / beta_full`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1246: `if x < (a + 1.0) / (a + b + 2.0) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1249: `bt * x.powf(a) * (1.0 - x).powf(b) / a`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1249: `bt * x.powf(a) * (1.0 - x).powf(b) / a`
  - **Fix**: Mathematical operation .powf( without validation
- Line 1253: `beta_function(a, b) - bt * (1.0 - x).powf(b) * x.powf(a) / b`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1253: `beta_function(a, b) - bt * (1.0 - x).powf(b) * x.powf(a) / b`
  - **Fix**: Mathematical operation .powf( without validation
- Line 1267: `let mut d = 1.0 - qab * x / qap;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1271: `d = 1.0 / d;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1278: `let aa = m as f64 * (b - m as f64) * x / ((qam + m2 as f64) * (a + m2 as f64));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1283: `c = 1.0 + aa / c;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1287: `d = 1.0 / d;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1291: `let aa = -(a + m as f64) * (qab + m as f64) * x / ((a + m2 as f64) * (qap + m2 a...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1296: `c = 1.0 + aa / c;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1300: `d = 1.0 / d;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1314: `gamma_function(a) * gamma_function(b) / gamma_function(a + b)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1325: `return std::f64::consts::PI / ((std::f64::consts::PI * x).sin() * gamma_function...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1344: `result += value / (z + (i + 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1350: `2.506628274631 * t.powf(z + 0.5) * (-t).exp() * result`
  - **Fix**: Mathematical operation .powf( without validation
- Line 1427: `let df = F::from(n - 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1431: `df.sqrt() * F::from(1e6).unwrap() // Large value simulating infinity`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1433: `rho * (df / (F::one() - rho * rho)).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1433: `rho * (df / (F::one() - rho * rho)).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1456: `F::from(2.0).unwrap() * (F::one() - student_t_cdf(t_stat.abs(), df))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1535: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1567: `let n0 = n * (n - 1) / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1573: `let n1_f = F::from(n1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1574: `let n2_f = F::from(n2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1575: `let n0_f = F::from(n0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1584: `let v0 = F::from(n * (n - 1) * (2 * n + 5)).unwrap() / F::from(18).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1585: `let v1 = F::from(ties_x * (ties_x - 1) * (2 * ties_x + 5)).unwrap() / F::from(18...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1586: `let v2 = F::from(ties_y * (ties_y - 1) * (2 * ties_y + 5)).unwrap() / F::from(18...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1588: `let v = (v0 - v1 - v2) / (n1_f * n2_f).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1588: `let v = (v0 - v1 - v2) / (n1_f * n2_f).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1589: `v / n0_f`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1593: `let m_f = F::from(m).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1595: `(F::from(2).unwrap() * (F::from(2).unwrap() * m_f + F::from(1).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1596: `/ (F::from(9).unwrap() * m_f * n_f * (n_f - F::one()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1600: `let z = tau / var_tau.sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1600: `let z = tau / var_tau.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1622: `F::from(2.0).unwrap() * F::min(normal_cdf(z.abs()), F::one() - normal_cdf(z.abs(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1631: `let z_f64 = <f64 as NumCast>::from(z).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1636: `let t = 1.0 / (1.0 + 0.2316419 * abs_z);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1643: `1.0 - (1.0 / (2.0 * std::f64::consts::PI).sqrt()) * (-0.5 * z_f64 * z_f64).exp()...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1643: `1.0 - (1.0 / (2.0 * std::f64::consts::PI).sqrt()) * (-0.5 * z_f64 * z_f64).exp()...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1645: `(1.0 / (2.0 * std::f64::consts::PI).sqrt()) * (-0.5 * z_f64 * z_f64).exp() * pol...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1645: `(1.0 / (2.0 * std::f64::consts::PI).sqrt()) * (-0.5 * z_f64 * z_f64).exp() * pol...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 1648: `F::from(p).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()

### src/correlation/intraclass.rs

47 issues found:

- Line 78: `let alpha = F::one() - conf_level.unwrap_or_else(|| F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 91: `subject_means[i] = sum / F::from(k).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 101: `rater_means[j] = sum / F::from(n).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 105: `grand_mean = grand_mean / F::from(n * k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `ss_subjects = ss_subjects + F::from(k).unwrap() * (mean - grand_mean).powi(2);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 126: `ss_raters = ss_raters + F::from(n).unwrap() * (mean - grand_mean).powi(2);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `let ms_subjects = ss_subjects / F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `let ms_raters = ss_raters / F::from(k - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 135: `let ms_residual = ss_residual / F::from((n - 1) * (k - 1)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 145: `let ms_within = (ss_raters + ss_residual) / F::from(n * (k - 1)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 152: `(ms_between - ms_within) / (ms_between + F::from(k - 1).unwrap() * ms_within)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 166: `+ F::from(k - 1).unwrap() * ms_residual`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 167: `+ (F::from(k).unwrap() * (ms_raters - ms_residual)) / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 168: `numerator / denominator`
  - **Fix**: Division without zero check - use safe_divide()
- Line 180: `(ms_subjects - ms_residual) / (ms_subjects + F::from(k - 1).unwrap() * ms_residu...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 189: `F::one() - alpha / F::from(2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 190: `F::from(n - 1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 191: `F::from((n - 1) * (k - 1)).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 194: `alpha / F::from(2.0).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 195: `F::from(n - 1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 196: `F::from((n - 1) * (k - 1)).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 203: `let f_l = F::one() / f_value_lower;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 207: `/ (f_l * ms_subjects + F::from(k - 1).unwrap() * ms_residual);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 210: `/ (f_u * ms_subjects + F::from(k - 1).unwrap() * ms_residual);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 216: `let f_l = F::one() / f_value_lower;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 220: `/ (f_l * ms_subjects`
  - **Fix**: Division without zero check - use safe_divide()
- Line 221: `+ F::from(k - 1).unwrap() * ms_residual`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 222: `+ F::from(k).unwrap() * (ms_raters - ms_residual) / F::from(n).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 225: `/ (f_u * ms_subjects`
  - **Fix**: Division without zero check - use safe_divide()
- Line 226: `+ F::from(k - 1).unwrap() * ms_residual`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 227: `+ F::from(k).unwrap() * (ms_raters - ms_residual) / F::from(n).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 233: `let f_l = F::one() / f_value_lower;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 237: `/ (f_l * ms_subjects + F::from(k - 1).unwrap() * ms_residual);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 240: `/ (f_u * ms_subjects + F::from(k - 1).unwrap() * ms_residual);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 252: `let p_f64 = <f64 as NumCast>::from(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 253: `let df1_f64 = <f64 as NumCast>::from(df1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 254: `let df2_f64 = <f64 as NumCast>::from(df2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 262: `return F::from(0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 265: `return F::from(1e10).unwrap(); // Very large value`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 272: `let a = 2.0 / (9.0 * df1_f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 273: `let b = 2.0 / (9.0 * df2_f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 274: `let c = z * (a + b).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 276: `let res = ((1.0 - b) * ((1.0 - c).powi(3) / (1.0 - a))).powi(-1);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 278: `F::from(res).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 293: `let t = (-2.0 * q.ln()).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 293: `let t = (-2.0 * q.ln()).sqrt();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 302: `let x = t - (c0 + c1 * t + c2 * t * t) / (1.0 + d1 * t + d2 * t * t + d3 * t * t...`
  - **Fix**: Division without zero check - use safe_divide()

### src/correlation_simd.rs

5 issues found:

- Line 91: `let corr = sum_xy / (sum_x2 * sum_y2).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 91: `let corr = sum_xy / (sum_x2 * sum_y2).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 116: `let corr = sum_xy / (sum_x2 * sum_y2).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 116: `let corr = sum_xy / (sum_x2 * sum_y2).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 233: `Ok(sum_xy / F::from(n - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()

### src/descriptive.rs

55 issues found:

- Line 41: `let count = NumCast::from(x.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 43: `Ok(sum / count)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 107: `Ok(weighted_sum / sum_of_weights)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 148: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 149: `.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 152: `let half = len / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 158: `Ok((mid1 + mid2) / (F::one() + F::one()))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 223: `let denominator = NumCast::from(x.len() - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 225: `Ok(sum_squared_diff / denominator)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 261: `Ok(variance.sqrt())`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 322: `let n = F::from(x.len() as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 329: `let variance = sum_sq_dev / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 330: `let third_moment = sum_cubed_dev / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 331: `let skew = third_moment / variance.powf(F::from(1.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 336: `let n_f = F::from(x.len() as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 337: `let sqrt_term = (n_f * (n_f - F::one())).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 338: `let correction = sqrt_term / (n_f - F::from(2.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 408: `let n = F::from(x.len() as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 420: `let variance = sum_sq_dev / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 421: `let fourth_moment = sum_fourth_dev / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 431: `F::from(-1.2).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 433: `F::from(1.8).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `k = fourth_moment / (variance * variance);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 439: `k = k - F::from(3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 447: `F::from(-1.3).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `F::from(1.7).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 453: `k = fourth_moment / (variance * variance);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 455: `k = k - F::from(3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 505: `let count = F::from(x.len() as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 506: `let order_f = F::from(moment_order as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 516: `diff.powf(order_f)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 520: `Ok(sum / count)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 523: `let sum = x.iter().map(|&val| val.powf(order_f)).sum::<F>();`
  - **Fix**: Mathematical operation .powf( without validation
- Line 525: `Ok(sum / count)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 539: `let result = mean(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 547: `let result = weighted_mean(&data.view(), &weights.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 554: `let result_odd = median(&data_odd.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 558: `let result_even = median(&data_even.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 567: `let pop_var = var(&data.view(), 0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 571: `let sample_var = var(&data.view(), 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 575: `let pop_std = std(&data.view(), 0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 579: `let sample_std = std(&data.view(), 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 588: `let first_raw = moment(&data.view(), 1, false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `let second_central = moment(&data.view(), 2, true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 596: `let third_central = moment(&data.view(), 3, true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 600: `let fourth_central = moment(&data.view(), 4, true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 608: `let sym_skew = skew(&sym_data.view(), true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 613: `let pos_skew = skew(&pos_skew_data.view(), true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 618: `let result = skew(&neg_skew_data.view(), true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 623: `let unbiased = skew(&pos_skew_data.view(), false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 632: `let fisher_biased = kurtosis(&data.view(), true, true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 636: `let pearson_biased = kurtosis(&data.view(), false, true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 640: `let fisher_unbiased = kurtosis(&data.view(), true, false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 645: `let peaked_kurtosis = kurtosis(&peaked_data.view(), true, true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 650: `let uniform_kurtosis = kurtosis(&uniform_data.view(), true, true).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/descriptive_simd.rs

12 issues found:

- Line 59: `Ok(sum / F::from(n).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 113: `Ok(sum_sq_dev / F::from(n - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 131: `variance_simd(x, ddof).map(|var| var.sqrt())`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 166: `let mean = sum / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 177: `let variance = sum_sq_dev / F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 198: `let mean = sum / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 199: `let variance = (sum_sq - sum * sum / F::from(n).unwrap()) / F::from(n - 1).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 214: `let result = mean_simd(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 221: `let result = variance_simd(&data.view(), 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 229: `let (mean, var, min, max) = descriptive_stats_simd(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 243: `let simd_mean = mean_simd(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 244: `let scalar_mean = crate::mean(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/dispersion.rs

49 issues found:

- Line 66: `let n = F::from(x.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 68: `Ok(sum_abs_dev / n)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 177: `let q1 = percentile(x, F::from(25.0).unwrap(), interp_method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 178: `let q3 = percentile(x, F::from(75.0).unwrap(), interp_method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 275: `let n = F::from(x.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 276: `let df_adjust = F::from(ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 285: `let std_dev = (sum_of_squares / (n - df_adjust)).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 285: `let std_dev = (sum_of_squares / (n - df_adjust)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 288: `Ok((std_dev / mean_val).abs())`
  - **Fix**: Division without zero check - use safe_divide()
- Line 304: `if q < F::zero() || q > F::from(100.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 315: `let n = F::from(sorted_data.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 316: `let q_scaled = q / F::from(100.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 322: `let i = index.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 326: `let i = index.ceil().to_usize().unwrap().min(sorted_data.len() - 1);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 330: `let i = index.round().to_usize().unwrap().min(sorted_data.len() - 1);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 334: `let i_lower = index.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 335: `let i_upper = index.ceil().to_usize().unwrap().min(sorted_data.len() - 1);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 336: `Ok((sorted_data[i_lower] + sorted_data[i_upper]) / F::from(2.0).unwrap())`
  - **Fix**: Use .get() with proper bounds checking
- Line 340: `let i_lower = index.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 341: `let i_upper = index.ceil().to_usize().unwrap().min(sorted_data.len() - 1);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 418: `let n = F::from(sorted_data.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 431: `.map(|(i, &value)| F::from(i + 1).unwrap() * value)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 435: `let gini = (F::from(2.0).unwrap() * weighted_sum / (n * sum_values)) - (n + F::o...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 451: `let mad = mean_abs_deviation(&data.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 456: `let mad_from_3 = mean_abs_deviation(&data.view(), Some(3.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 460: `let mad_from_0 = mean_abs_deviation(&data.view(), Some(0.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 470: `let mad = median_abs_deviation(&data.view(), None, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 475: `let mad_scaled = median_abs_deviation(&data.view(), None, Some(1.4826)).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 480: `let mad_with_outlier = median_abs_deviation(&data_with_outlier.view(), None, Non...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 490: `let iqr_val = iqr(&data.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 495: `let iqr_lower = iqr(&data.view(), Some("lower")).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 498: `let iqr_higher = iqr(&data.view(), Some("higher")).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 503: `let iqr_even = iqr(&even_data.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 518: `let range_val = data_range(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 524: `let range_single = data_range(&single_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 533: `let cv = coef_variation(&data.view(), 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 538: `let cv_pop = coef_variation(&data.view(), 0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `let p25 = percentile(&data.view(), 25.0, "linear").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 551: `let p50 = percentile(&data.view(), 50.0, "linear").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 554: `let p75 = percentile(&data.view(), 75.0, "linear").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 560: `let p50_even = percentile(&even_data.view(), 50.0, "linear").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 564: `let p60_linear = percentile(&data.view(), 60.0, "linear").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 565: `let p60_lower = percentile(&data.view(), 60.0, "lower").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 566: `let p60_higher = percentile(&data.view(), 60.0, "higher").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 567: `let p60_nearest = percentile(&data.view(), 60.0, "nearest").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 568: `let p60_midpoint = percentile(&data.view(), 60.0, "midpoint").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 587: `let gini_equal = gini_coefficient(&equal_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `let gini_unequal = gini_coefficient(&unequal_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 601: `let gini_income = gini_coefficient(&income_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/dispersion_simd.rs

21 issues found:

- Line 127: `let q1 = quantile_simd(x, F::from(0.25).unwrap(), interpolation)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 128: `let q3 = quantile_simd(x, F::from(0.75).unwrap(), interpolation)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 193: `Ok(std / mean.abs())`
  - **Fix**: Division without zero check - use safe_divide()
- Line 255: `let sorted_slice = sorted_data.as_slice_mut().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 263: `let indices = ndarray::Array1::from_shape_fn(n, |i| F::from(i + 1).unwrap());`
  - **Fix**: Handle array creation errors properly
- Line 272: `let gini = (F::from(2).unwrap() * weighted_sum) / (F::from(n).unwrap() * total_s...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 273: `- F::from(n + 1).unwrap() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 283: `weighted_sum = weighted_sum + F::from(i + 1).unwrap() * val;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 290: `let gini = (F::from(2).unwrap() * weighted_sum) / (F::from(n).unwrap() * cumsum)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 291: `- F::from(n + 1).unwrap() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 313: `Ok(std_dev / F::from(n).unwrap().sqrt())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 372: `if lower_pct < F::zero() || lower_pct > F::from(100).unwrap() ||`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 373: `upper_pct < F::zero() || upper_pct > F::from(100).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 381: `let lower_q = lower_pct / F::from(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 382: `let upper_q = upper_pct / F::from(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 399: `let result = mad_simd(&mut data.view_mut(), 1.0, "propagate").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 408: `let cv = coefficient_of_variation_simd(&data.view(), "propagate").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 417: `let range = range_simd(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 425: `let gini_equal = gini_simd(&equal_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 430: `let gini_unequal = gini_simd(&unequal_data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `let sem = sem_simd(&data.view(), 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distribution_characteristics.rs

33 issues found:

- Line 173: `let p = count as f64 / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 233: `let tol = F::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 258: `let ratio = *p_i / *q_i;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 259: `divergence = divergence + *p_i * ratio.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 312: `let tol = F::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 337: `cross_ent = cross_ent - *p_i * q_i.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 410: `let conf = confidence.unwrap_or(F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 439: `let alpha = (F::one() - conf) / (F::one() + F::one());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 440: `let lower_idx = (alpha * F::from(bootstrap_skew.len()).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 442: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `let upper_idx = ((F::one() - alpha) * F::from(bootstrap_skew.len()).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 445: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 511: `let conf = confidence.unwrap_or(F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 540: `let alpha = (F::one() - conf) / (F::one() + F::one());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 541: `let lower_idx = (alpha * F::from(bootstrap_kurt.len()).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 543: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 544: `let upper_idx = ((F::one() - alpha) * F::from(bootstrap_kurt.len()).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 546: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 570: `let result = mode(&data.view(), ModeMethod::Unimodal).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 579: `let result = mode(&data.view(), ModeMethod::MultiModal).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 589: `let entropy_uniform = entropy(&uniform.view(), Some(2.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 594: `let entropy_less = entropy(&less_uniform.view(), Some(2.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 599: `let entropy_single = entropy(&single.view(), Some(2.0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 609: `let div = kl_divergence(&p.view(), &q.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 613: `let div_reverse = kl_divergence(&q.view(), &p.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `let same = kl_divergence(&p.view(), &p.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 627: `let cross_ent = cross_entropy(&p.view(), &q.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 630: `let entropy_p = -0.5f64 * (0.5f64.ln()) - 0.5 * (0.5f64.ln());`
  - **Fix**: Mathematical operation .ln() without validation
- Line 631: `let kl = kl_divergence(&p.view(), &q.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 639: `let result = skewness_ci(&data.view(), false, None, Some(100), Some(42)).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 642: `let direct_skew = skew(&data.view(), false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 656: `let result = kurtosis_ci(&data.view(), true, false, None, Some(100), Some(42)).u...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 659: `let direct_kurt = kurtosis(&data.view(), true, false).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/bernoulli.rs

43 issues found:

- Line 47: `let p_f64 = <f64 as num_traits::NumCast>::from(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `(one - self.p).ln() // ln(q) = ln(1 - p)`
  - **Fix**: Mathematical operation .ln() without validation
- Line 128: `self.p.ln() // ln(p)`
  - **Fix**: Mathematical operation .ln() without validation
- Line 300: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 320: `let one = F::from(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 321: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 330: `(one - two * self.p) / (self.p * q).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 330: `(one - two * self.p) / (self.p * q).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 350: `let one = F::from(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 351: `let six = F::from(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 361: `(one - six * pq) / pq`
  - **Fix**: Division without zero check - use safe_divide()
- Line 392: `-(self.p * self.p.ln() + q * q.ln())`
  - **Fix**: Mathematical operation .ln() without validation
- Line 413: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 445: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 504: `let bern1 = Bernoulli::new(0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 507: `let bern2 = Bernoulli::new(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 510: `let bern3 = Bernoulli::new(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 520: `let bern = Bernoulli::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 535: `let bern_zero = Bernoulli::new(0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 539: `let bern_one = Bernoulli::new(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 546: `let bern = Bernoulli::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 550: `assert_relative_eq!(log_pmf_at_zero, 0.7.ln(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 554: `assert_relative_eq!(log_pmf_at_one, 0.3.ln(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 561: `let bern_zero = Bernoulli::new(0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 565: `let bern_one = Bernoulli::new(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 572: `let bern = Bernoulli::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `let bern = Bernoulli::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 587: `assert_eq!(bern.ppf(0.0).unwrap(), 0.0); // Q(0) = 0`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 588: `assert_eq!(bern.ppf(0.3).unwrap(), 0.0); // Q(0.3) = 0 since 0.3 â‰¤ q = 0.7`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 589: `assert_eq!(bern.ppf(0.7).unwrap(), 0.0); // Q(0.7) = 0 since 0.7 = q = 0.7`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 590: `assert_eq!(bern.ppf(0.71).unwrap(), 1.0); // Q(0.71) = 1 since 0.71 > q = 0.7`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 591: `assert_eq!(bern.ppf(1.0).unwrap(), 1.0); // Q(1) = 1`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 600: `let bern = Bernoulli::new(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 603: `let samples = bern.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 615: `let mean = sum / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 624: `let bern = Bernoulli::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 633: `assert_relative_eq!(bern.std(), 0.21_f64.sqrt(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 636: `let expected_skewness = (1.0 - 2.0 * 0.3) / (0.3 * 0.7).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 636: `let expected_skewness = (1.0 - 2.0 * 0.3) / (0.3 * 0.7).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 640: `let expected_kurtosis = (1.0 - 6.0 * 0.3 * 0.7) / (0.3 * 0.7);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 644: `let expected_entropy = -0.3 * 0.3.ln() - 0.7 * 0.7.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 652: `let bern2 = Bernoulli::new(0.8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 659: `let bern3 = Bernoulli::new(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/beta.rs

134 issues found:

- Line 68: `let alpha_f64 = <f64 as NumCast>::from(alpha).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 69: `let beta_f64 = <f64 as NumCast>::from(beta).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 107: `let x_adj = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 115: `return F::one() / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 128: `if (self.alpha - F::from(2.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 129: `&& (self.beta - F::from(5.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 130: `&& (x_adj - F::from(0.2).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 132: `return F::from(3.2768).unwrap() / self.scale;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 136: `if (self.alpha - F::from(2.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 137: `&& (self.beta - F::from(3.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 138: `&& (x_adj - F::from(0.5).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 140: `return F::from(1.875).unwrap() / self.scale;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 144: `let numerator = x_adj.powf(self.alpha - one) * (one - x_adj).powf(self.beta - on...`
  - **Fix**: Mathematical operation .powf( without validation
- Line 148: `numerator / (denominator * self.scale)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 172: `let x_adj = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 200: `if (self.alpha - F::from(2.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 201: `&& (self.beta - F::from(2.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 202: `&& (x_adj - F::from(0.5).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 204: `return F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 207: `if (self.alpha - F::from(2.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 208: `&& (self.beta - F::from(2.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 209: `&& (x_adj - F::from(0.8).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 211: `return F::from(0.896).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 214: `if (self.alpha - F::from(2.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 215: `&& (self.beta - F::from(5.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 216: `&& (x_adj - F::from(0.2).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 218: `return F::from(0.2627).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 261: `if p == F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 262: `return Ok(self.loc + self.scale * F::from(0.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 267: `if (self.alpha - F::from(2.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 268: `&& (self.beta - F::from(5.0).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `&& (p - F::from(0.2627).unwrap()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 271: `return Ok(self.loc + F::from(0.2).unwrap() * self.scale);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 282: `let x_unit = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 286: `.max(F::from(1e-10).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 287: `.min(F::from(1.0 - 1e-10).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 291: `if (cdf_x - p).abs() < F::from(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 302: `let delta = (cdf_x - p) / pdf_x;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 337: `samples.push(F::from(sample).unwrap() * self.scale + self.loc);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 374: `ga * gb / gab`
  - **Fix**: Division without zero check - use safe_divide()
- Line 382: `F::from(676.520_368_121_885_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 383: `F::from(-1_259.139_216_722_403).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 384: `F::from(771.323_428_777_653_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 385: `F::from(-176.615_029_162_140_6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 386: `F::from(12.507_343_278_686_9).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 387: `F::from(-0.138_571_095_265_72).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 388: `F::from(9.984_369_578_019_572e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 389: `F::from(1.505_632_735_149_31e-7).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 393: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 394: `let sqrt_2pi = F::from(2.506_628_274_631).unwrap(); // sqrt(2*pi)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 395: `let g = F::from(7).unwrap(); // Lanczos parameter`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 399: `let sinpx = (F::from(std::f64::consts::PI).unwrap() * x).sin();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 400: `return F::from(std::f64::consts::PI).unwrap() / (sinpx * gamma_fn(one - x));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 407: `let mut acc = F::from(0.999_999_999_999_809_9).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `let i_f = F::from(i).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 410: `acc = acc + coef / (z + i_f + one);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 414: `sqrt_2pi * t.powf(z + half) * (-t).exp() * acc`
  - **Fix**: Mathematical operation .powf( without validation
- Line 429: `if alpha > F::from(8.0).unwrap() && beta > F::from(8.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 431: `let mu = alpha / (alpha + beta);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 433: `(alpha * beta / ((alpha + beta) * (alpha + beta) * (alpha + beta + one))).sqrt()...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 433: `(alpha * beta / ((alpha + beta) * (alpha + beta) * (alpha + beta + one))).sqrt()...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 440: `if (alpha - beta).abs() < F::from(0.01).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 441: `if p <= F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 442: `return p.powf(one / alpha);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 442: `return p.powf(one / alpha);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 444: `return one - (one - p).powf(one / alpha);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 444: `return one - (one - p).powf(one / alpha);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 454: `if p < F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 456: `let approx = p.powf(one / alpha);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 456: `let approx = p.powf(one / alpha);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 458: `.max(F::from(1e-10).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `.min(one - F::from(1e-10).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 462: `let approx = one - ((one - p).powf(one / beta));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 462: `let approx = one - ((one - p).powf(one / beta));`
  - **Fix**: Mathematical operation .powf( without validation
- Line 464: `.max(F::from(1e-10).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 465: `.min(one - F::from(1e-10).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 481: `if x > (a + one) / (a + b + F::from(2.0).unwrap()) {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 490: `let xu = x.powf(a) * (one - x).powf(b) / bt;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 490: `let xu = x.powf(a) * (one - x).powf(b) / bt;`
  - **Fix**: Mathematical operation .powf( without validation
- Line 495: `let big = F::from(1e30).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 497: `if xu < F::from(1e-30).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 503: `let eps = F::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 511: `let _m_f = F::from(m).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 512: `let m2 = F::from(2 * m).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 516: `let d_m = F::from(m / 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 517: `a_i = d_m * (b - d_m) * x / ((a + m2 - one) * (a + m2));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 520: `let d_m = F::from((m + 1) / 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 521: `a_i = -d_m * (a + d_m - one) * x / ((a + m2 - one) * (a + m2));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 525: `if a_i.abs() < F::from(1e-30).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 528: `d = one / a_i;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 544: `let res = xu / a * h;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 552: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 558: `let t = (-F::from(2.0).unwrap() * p_adj.ln()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 561: `let c0 = F::from(2.515517).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 562: `let c1 = F::from(0.802853).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 563: `let c2 = F::from(0.010328).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 564: `let d1 = F::from(1.432788).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 565: `let d2 = F::from(0.189269).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 566: `let d3 = F::from(0.001308).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 571: `let result = t - numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 583: `if p < F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 589: `F::from(f64::MIN_POSITIVE).unwrap() // Smallest positive float`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 608: `self.alpha / (self.alpha + self.beta)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 616: `(self.alpha * self.beta) / (sum_squared * (sum + F::one())) * self.scale * self....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 621: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 637: `bf.ln() + (self.scale.ln())`
  - **Fix**: Mathematical operation .ln() without validation
- Line 667: `let uniform = Beta::new(1.0, 1.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 674: `let custom = Beta::new(2.0, 3.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 692: `let uniform = Beta::new(1.0, 1.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 698: `let bell = Beta::new(2.0, 2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 704: `let skewed = Beta::new(2.0, 5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 710: `let shifted = Beta::new(2.0, 2.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 719: `let uniform = Beta::new(1.0, 1.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 725: `let bell = Beta::new(2.0, 2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 732: `let skewed = Beta::new(2.0, 5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 741: `let uniform = Beta::new(1.0, 1.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 742: `assert_relative_eq!(uniform.ppf(0.0).unwrap(), 0.0, epsilon = 1e-6);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 743: `assert_relative_eq!(uniform.ppf(0.5).unwrap(), 0.5, epsilon = 1e-6);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 744: `assert_relative_eq!(uniform.ppf(1.0).unwrap(), 1.0, epsilon = 1e-6);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 747: `let bell = Beta::new(2.0, 2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 748: `assert_relative_eq!(bell.ppf(0.5).unwrap(), 0.5, epsilon = 1e-6);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 751: `let skewed = Beta::new(2.0, 5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 752: `let x = skewed.ppf(0.2627).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 756: `let shifted = Beta::new(2.0, 2.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 757: `assert_relative_eq!(shifted.ppf(0.5).unwrap(), 2.0, epsilon = 1e-6);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 766: `let beta = Beta::new(2.0, 3.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 769: `let samples_vec = beta.rvs_vec(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 770: `let samples = beta.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 778: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 791: `let mean_array = sum_array / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 799: `let beta = Beta::new(2.0, 3.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 820: `let ppf = ContinuousDistribution::ppf(&beta, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 821: `let direct_ppf = beta.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 835: `assert_relative_eq!(beta_function(2.0, 3.0), 1.0 / 12.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()

### src/distributions/binomial.rs

65 issues found:

- Line 53: `let p_f64 = <f64 as num_traits::NumCast>::from(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 90: `if k < zero || k > F::from(self.n).unwrap() || !Self::is_integer(k) {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 94: `let k_usize = k.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 111: `let p_pow_k = self.p.powf(F::from(k_usize).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 112: `let q_pow_nk = (one - self.p).powf(F::from(self.n - k_usize).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 142: `if k < zero || k > F::from(self.n).unwrap() || !Self::is_integer(k) {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 146: `let k_usize = k.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 167: `let ln_p_pow_k = F::from(k_usize).unwrap() * self.p.ln();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 168: `let ln_q_pow_nk = F::from(self.n - k_usize).unwrap() * (one - self.p).ln();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 202: `if k >= F::from(self.n).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 208: `let k_int = k_floor.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 213: `sum = sum + self.pmf(F::from(i).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 253: `return Ok(F::from(self.n).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 266: `mid = (low + high) / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 267: `let mid_f = F::from(mid).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 280: `Ok(F::from(low).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 309: `let sample_f = F::from(sample).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 333: `F::from(self.n).unwrap() * self.p`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 354: `F::from(self.n).unwrap() * self.p * (one - self.p)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 374: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 395: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 397: `let n_f = F::from(self.n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `(one - two * self.p) / (n_f * self.p * q).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 405: `(one - two * self.p) / (n_f * self.p * q).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 426: `let six = F::from(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 428: `let n_f = F::from(self.n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `(one - six * pq) / (n_f * pq)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 458: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `let two_pi_e = F::from(2.0 * std::f64::consts::PI * std::f64::consts::E).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 468: `half * (two_pi_e * variance).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 487: `let n_plus_1 = F::from(self.n + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 521: `if mean - mean.floor() < F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 539: `result = result * (self.n - i) as u64 / (i + 1) as u64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 541: `F::from(result).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 556: `F::from(result).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 605: `let binom1 = Binomial::new(10, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 609: `let binom2 = Binomial::new(0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 621: `let binom = Binomial::new(10, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 637: `let binom_zero = Binomial::new(0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 642: `let binom_p0 = Binomial::new(10, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 647: `let binom_p1 = Binomial::new(10, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 655: `let binom = Binomial::new(10, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 664: `assert_relative_eq!(log_pmf, pmf.ln(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 681: `let binom = Binomial::new(10, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 698: `let binom = Binomial::new(10, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 704: `let ppf = binom.ppf(cdf).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 711: `assert_eq!(binom.ppf(0.0).unwrap(), 0.0);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 712: `assert_eq!(binom.ppf(1.0).unwrap(), 10.0);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 715: `assert_eq!(binom.ppf(0.5).unwrap(), 5.0);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 725: `let binom = Binomial::new(10, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 728: `let samples = binom.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 741: `let mean = sum / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 750: `let binom = Binomial::new(10, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 759: `assert_relative_eq!(binom.std(), 2.1_f64.sqrt(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 762: `let expected_skewness = (1.0 - 2.0 * 0.3) / (10.0 * 0.3 * 0.7).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 762: `let expected_skewness = (1.0 - 2.0 * 0.3) / (10.0 * 0.3 * 0.7).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 766: `let expected_kurtosis = (1.0 - 6.0 * 0.3 * 0.7) / (10.0 * 0.3 * 0.7);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 773: `let binom1 = Binomial::new(10, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 778: `let binom2 = Binomial::new(10, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 784: `let binom3 = Binomial::new(9, 0.4).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 792: `let binom1 = Binomial::new(10, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 796: `let binom2 = Binomial::new(10, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 800: `let binom3 = Binomial::new(9, 0.4).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 806: `let binom = Binomial::new(10, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 816: `let binom_large = Binomial::new(100, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/cauchy.rs

37 issues found:

- Line 90: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 94: `let z = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 95: `one / (pi * self.scale * (one + z * z))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 118: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 119: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `let z = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 123: `half + z.atan() / pi`
  - **Fix**: Division without zero check - use safe_divide()
- Line 152: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 153: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 195: `let u_f = F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 216: `let u_f = F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 330: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 331: `let four = F::from(4.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 334: `(four * pi * self.scale).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 432: `let cauchy = Cauchy::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `let custom = Cauchy::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `let cauchy = Cauchy::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 464: `let custom = Cauchy::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 478: `let cauchy = Cauchy::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 493: `let custom = Cauchy::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 507: `let cauchy = Cauchy::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 510: `let ppf_at_half = cauchy.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 514: `let ppf_at_75 = cauchy.ppf(0.75).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 518: `let ppf_at_25 = cauchy.ppf(0.25).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 522: `let custom = Cauchy::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 525: `let ppf_at_half_custom = custom.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 529: `let ppf_at_75_custom = custom.ppf(0.75).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 540: `let cauchy = Cauchy::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 559: `let custom = Cauchy::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 580: `let cauchy = Cauchy::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 583: `let samples_vec = cauchy.rvs_vec(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `let samples = cauchy.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 596: `sorted_samples.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 598: `(sorted_samples[49] + sorted_samples[50]) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 611: `let cauchy = Cauchy::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 616: `let x = cauchy.ppf(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 625: `let x_back = cauchy.ppf(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/chi_square.rs

119 issues found:

- Line 60: `let df_f64 = <f64 as NumCast>::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `let x_std = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 108: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 110: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 113: `let pow_term = x_std.powf(df_half - one);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 118: `let power_of_two = two.powf(df_half);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 119: `let normalization = one / (power_of_two * gamma_df_half);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 122: `normalization * pow_term * exp_term / self.scale`
  - **Fix**: Division without zero check - use safe_divide()
- Line 147: `let x_std = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 159: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 163: `if (self.df - F::from(2.0).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 165: `if (x_std - F::from(2.0).unwrap()).abs() < F::from(0.01).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 166: `return F::from(0.632).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 172: `if (self.df - F::from(5.0).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 174: `if (x_std - F::from(5.0).unwrap()).abs() < F::from(0.01).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 175: `return F::from(0.583).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 180: `let df_int = (self.df + F::from(0.5).unwrap()).floor();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 181: `if (self.df - df_int).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 182: `let df_int_val = <u32 as NumCast>::from(df_int).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 187: `if (self.df - F::one()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 189: `if (x_std - F::from(3.84).unwrap()).abs() < F::from(0.01).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 190: `return F::from(0.95).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 254: `let sample = F::from(std_sample).unwrap() * self.scale + self.loc;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 265: `let df_f64 = <f64 as NumCast>::from(self.df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 275: `let rand_distr = RandChiSquared::new(df_f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 277: `F::from(sample).unwrap() * scale + loc`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 290: `if x.abs() < F::from(0.01).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 297: `let term2 = x2 * F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 298: `let term3 = x3 * F::from(1.0 / 6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 299: `let term4 = x4 * F::from(1.0 / 24.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 311: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 317: `if (x - F::from(3.84).unwrap()).abs() < F::from(0.01).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 318: `return F::from(0.95).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 322: `let z = x.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 323: `return F::from(2.0).unwrap() * (F::from(0.5).unwrap() - half * (-z).exp());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 327: `if (x - F::from(2.0).unwrap()).abs() < F::from(0.01).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 328: `return F::from(0.632).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 341: `for i in 0..df / 2 {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 342: `let i_f = F::from(i).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 343: `term = term * x * half / (i_f + one);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 356: `let epsilon = F::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 370: `term = term * x / (a + n);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 374: `if n > F::from(1000.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `let factor = x.powf(a) * (-x).exp() / gamma_function(a);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 379: `let factor = x.powf(a) * (-x).exp() / gamma_function(a);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 385: `let mut c = F::from(1.0 / 1e-30).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 386: `let mut d = one / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 390: `while i < F::from(1000.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 392: `let b_term = b + F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 395: `d = one / (b + a_term * d);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 396: `c = b + a_term / c;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 407: `one - h * x.powf(a) * (-x).exp() / gamma_function(a)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 407: `one - h * x.powf(a) * (-x).exp() / gamma_function(a)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 417: `if x == F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 418: `return F::from(PI).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 428: `F::from(676.5203681218851).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 429: `F::from(-1259.1392167224028).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 430: `F::from(771.323_428_777_653_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 431: `F::from(-176.615_029_162_140_6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 432: `F::from(12.507343278686905).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 433: `F::from(-0.13857109526572012).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `F::from(9.984_369_578_019_572e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 435: `F::from(1.5056327351493116e-7).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 439: `let t = x_adj + F::from(7.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `sum = sum + coef / (x_adj + F::from(i + 1).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 446: `let pi = F::from(PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 447: `let sqrt_2pi = (F::from(2.0).unwrap() * pi).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `sqrt_2pi * sum * t.powf(x_adj + F::from(0.5).unwrap()) * (-t).exp()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `F::from(2.0).unwrap() * self.df * self.scale * self.scale`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 466: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 476: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 478: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 485: `let gamma = F::from(0.5772156649015329).unwrap(); // Euler-Mascheroni constant`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 486: `return one + gamma + self.scale.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 492: `k_half.ln() - one / (two * k_half)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 492: `k_half.ln() - one / (two * k_half)`
  - **Fix**: Mathematical operation .ln() without validation
- Line 495: `k_half.ln() - half / k_half`
  - **Fix**: Division without zero check - use safe_divide()
- Line 495: `k_half.ln() - half / k_half`
  - **Fix**: Mathematical operation .ln() without validation
- Line 501: `(k_half) + (two * gamma_k_half).ln() + (one - k_half) * digamma_k_half + self.sc...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 537: `let df2 = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 538: `let df5 = F::from(5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 540: `if (df - df1).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 542: `if (p - F::from(0.95).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 543: `return Ok(self.loc + F::from(3.841).unwrap() * self.scale);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 545: `if (p - F::from(0.99).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 546: `return Ok(self.loc + F::from(6.635).unwrap() * self.scale);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `} else if (df - df2).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 550: `let result = -F::from(2.0).unwrap() * (F::one() - p).ln();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 552: `} else if (df - df5).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 554: `if (p - F::from(0.95).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 555: `return Ok(self.loc + F::from(11.070).unwrap() * self.scale);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 561: `let z = if p > F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 562: `(F::from(-2.0).unwrap() * (F::one() - p).ln()).sqrt()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 564: `-(F::from(-2.0).unwrap() * p.ln()).sqrt()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 567: `let term1 = df * (F::one() - F::from(2.0).unwrap() / (F::from(9.0).unwrap() * df...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 568: `let term2 = F::from(2.0).unwrap() / F::from(9.0).unwrap() * z / df.sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 569: `let term3 = F::from(3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 571: `let result = term1 * (F::one() + term2).powf(term3);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 592: `let chi2 = ChiSquare::new(2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 598: `let custom = ChiSquare::new(5.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 613: `let chi2 = ChiSquare::new(2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 628: `let chi5 = ChiSquare::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 638: `let chi1 = ChiSquare::new(1.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 649: `let chi2 = ChiSquare::new(2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 656: `let chi5 = ChiSquare::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 666: `let chi1 = ChiSquare::new(1.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 669: `let p95 = chi1.ppf(0.95).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 673: `let chi2 = ChiSquare::new(2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 676: `let p95_2 = chi2.ppf(0.95).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 683: `let chi2 = ChiSquare::new(2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 686: `let samples_vec = chi2.rvs_vec(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 690: `let samples_array = chi2.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 695: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 704: `let chi2 = ChiSquare::new(2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 716: `let chi5_scale2 = ChiSquare::new(5.0, 0.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 724: `let chi2 = ChiSquare::new(2.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 736: `assert_relative_eq!(dist.ppf(0.95).unwrap(), 5.991, epsilon = 1e-3);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 745: `dist.isf(0.95).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 746: `dist.ppf(0.05).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/circular/von_mises.rs

54 issues found:

- Line 87: `let two_pi = F::from(2.0 * PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 88: `let pi = F::from(PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 106: `let x_f64 = x.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 108: `F::from(result).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 114: `let x_f64 = x.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 116: `F::from(result).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `let x_f64 = x.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 124: `F::from(result).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 130: `let x_f64 = x.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 132: `F::from(result).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 139: `let x_f64 = x.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 141: `return F::from(-x_f64 * x_f64 / 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 152: `let kappa_f64 = kappa.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 153: `let x_f64 = x.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 157: `return F::from((x_f64 + std::f64::consts::PI) / (2.0 * std::f64::consts::PI)).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 175: `let sigma = 1.0 / kappa_f64.sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 175: `let sigma = 1.0 / kappa_f64.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 176: `let z = x_norm / (std::f64::consts::SQRT_2 * sigma);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 178: `let cdf = 0.5 * (1.0 + z / (1.0 + z * z / 2.0).sqrt());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 178: `let cdf = 0.5 * (1.0 + z / (1.0 + z * z / 2.0).sqrt());`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 179: `return F::from(cdf).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 190: `cdf = cdf / two_pi + x_norm / two_pi;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 191: `F::from(cdf).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 206: `one - self.bessel_i1(self.kappa) / self.bessel_i0(self.kappa)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 212: `let neg_two = F::from(-2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 213: `(neg_two * (F::one() - var).ln()).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 213: `(neg_two * (F::one() - var).ln()).sqrt()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 218: `let mu_f64 = self.mu.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 219: `let kappa_f64 = self.kappa.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 232: `samples[i] = F::from(sample).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 242: `let two_pi = F::from(2.0 * PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 245: `return two_pi.ln(); // Entropy of a uniform distribution on the circle`
  - **Fix**: Mathematical operation .ln() without validation
- Line 251: `let ratio = i1e / i0e;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 253: `-kappa * ratio + (two_pi * self.bessel_i0(kappa)).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 264: `let two_pi = F::from(2.0 * PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 268: `(self.kappa * cosm1_term).exp() / (two_pi * i0e)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 279: `let mu_f64 = self.mu.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 280: `let kappa_f64 = self.kappa.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 291: `Ok(F::from(sample).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 306: `let neg_two = F::from(-2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 307: `(neg_two * self.mean_resultant_length().ln()).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 307: `(neg_two * self.mean_resultant_length().ln()).sqrt()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 316: `self.bessel_i1(self.kappa) / self.bessel_i0(self.kappa)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 361: `let vm = von_mises(0.0f64, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 365: `let expected = 1.0 / (2.0 * PI * special::bessel::i0(1.0));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 383: `let vm = von_mises(mu, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 384: `assert_abs_diff_eq!(vm.circular_mean().to_f64().unwrap(), mu, epsilon = 1e-10);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 392: `let vm = von_mises(0.0, kappa).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 393: `assert_abs_diff_eq!(vm.concentration().to_f64().unwrap(), kappa, epsilon = 1e-10...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 400: `let vm = von_mises(0.0f64, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 404: `let vm = von_mises(0.0f64, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `let expected = special::bessel::i1(1.0) / special::bessel::i0(1.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 411: `let vm = von_mises(0.0f64, 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 412: `let samples = vm.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/circular/wrapped_cauchy.rs

33 issues found:

- Line 82: `let two_pi = F::from(2.0 * PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 106: `let neg_two = F::from(-2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 107: `(neg_two * self.gamma.ln()).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 107: `(neg_two * self.gamma.ln()).sqrt()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 121: `let two_pi = F::from(2.0 * PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `(two_pi * (F::one() - self.gamma * self.gamma)).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 129: `let two_pi = F::from(2.0 * PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 132: `F::from(2.0).unwrap() * self.gamma * (x - self.mu).cos();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `one_minus_gamma_sq / (two_pi * denom)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 139: `let two_pi = F::from(2.0 * PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 140: `let pi = F::from(PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 147: `let cr = (F::one() + self.gamma) / (F::one() - self.gamma);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 151: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 152: `let pi_inv = F::from(1.0 / PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 156: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 157: `let pi_inv = F::from(1.0 / PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 172: `let u_f64 = F::from(u).unwrap().to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 173: `let gamma_f64 = self.gamma.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 174: `let mu_f64 = self.mu.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 177: `let angle = 2.0 * (pi_u.tan() / gamma_f64).atan();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 182: `Ok(F::from(result).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 197: `let neg_two = F::from(-2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 198: `(neg_two * self.mean_resultant_length().ln()).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 198: `(neg_two * self.mean_resultant_length().ln()).sqrt()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 252: `let wc = wrapped_cauchy(0.0f64, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 256: `let expected = (1.0 - 0.5 * 0.5) / (2.0 * PI * (1.0 + 0.5 * 0.5 - 2.0 * 0.5 * 1....`
  - **Fix**: Division without zero check - use safe_divide()
- Line 267: `let wc = wrapped_cauchy(0.0f64, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 286: `let wc = wrapped_cauchy(0.0f64, gamma).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 293: `let wc = wrapped_cauchy(0.0f64, 0.8).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 294: `let samples = wc.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 299: `let sample_f64 = sample.to_f64().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 305: `let sin_sum: f64 = samples.iter().map(|&x| x.to_f64().unwrap().sin()).sum();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 306: `let cos_sum: f64 = samples.iter().map(|&x| x.to_f64().unwrap().cos()).sum();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/exponential.rs

39 issues found:

- Line 49: `let scale = F::one() / rate;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 52: `let rate_f64 = <f64 as NumCast>::from(rate).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 88: `let rate = F::one() / scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 91: `let rate_f64 = <f64 as NumCast>::from(rate).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 207: `let result = -((F::one() - p).ln()) / self.rate;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 207: `let result = -((F::one() - p).ln()) / self.rate;`
  - **Fix**: Mathematical operation .ln() without validation
- Line 297: `samples.push(F::from(sample).unwrap() + self.loc);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 315: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 324: `F::one() - self.rate.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 359: `let exp = Exponential::new(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 365: `let exp_scale = Exponential::from_scale(2.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 371: `let custom = Exponential::new(2.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 386: `let exp = Exponential::new(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 404: `let exp2 = Exponential::new(2.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `let shifted = Exponential::new(1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 418: `let exp = Exponential::new(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 436: `let exp2 = Exponential::new(2.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 441: `let shifted = Exponential::new(1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 450: `let exp = Exponential::new(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 453: `let median = exp.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 457: `let p95 = exp.ppf(0.95).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `let shifted = Exponential::new(1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 462: `assert_relative_eq!(shifted.ppf(0.5).unwrap(), 1.69314718, epsilon = 1e-7);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 472: `let exp = Exponential::new(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `let exp2 = Exponential::new(2.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 482: `let shifted = Exponential::new(1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 489: `let exp = Exponential::new(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 492: `let samples_vec = exp.rvs_vec(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 496: `let samples_array = exp.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 501: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 511: `/ 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 525: `let exp = Exponential::new(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 533: `let samples = exp.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 540: `let exp2 = Exponential::new(2.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 542: `assert_relative_eq!(exp2.entropy(), 1.0 - 2.0f64.ln(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 547: `let exp = Exponential::new(1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 559: `assert_relative_eq!(dist.ppf(0.5).unwrap(), 0.69314718, epsilon = 1e-7);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 572: `dist.isf(0.5).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 573: `dist.ppf(0.5).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/f.rs

71 issues found:

- Line 67: `let dfn_f64 = <f64 as NumCast>::from(dfn).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 68: `let dfd_f64 = <f64 as NumCast>::from(dfd).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `let x_std = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 113: `let is_df1_2 = (self.dfn - T::from(2.0).unwrap()).abs() < T::from(0.001).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 114: `let is_df1_5 = (self.dfn - T::from(5.0).unwrap()).abs() < T::from(0.001).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 115: `let is_df2_10 = (self.dfd - T::from(10.0).unwrap()).abs() < T::from(0.001).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 116: `let is_df2_20 = (self.dfd - T::from(20.0).unwrap()).abs() < T::from(0.001).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 117: `let is_x_1 = (x_std - T::one()).abs() < T::from(0.001).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 118: `let is_x_2 = (x_std - T::from(2.0).unwrap()).abs() < T::from(0.001).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `return T::from(0.335).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 125: `return T::from(0.133).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 129: `return T::from(0.31).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `let two = T::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 135: `let dfn_half = self.dfn / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 136: `let dfd_half = self.dfd / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 139: `let term1 = (self.dfn * x_std).powf(dfn_half);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 140: `let term2 = (self.dfd + self.dfn * x_std).powf(dfn_half + dfd_half);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 145: `let numer = term1 * (self.dfd.powf(dfd_half));`
  - **Fix**: Mathematical operation .powf( without validation
- Line 148: `numer / denom / self.scale`
  - **Fix**: Division without zero check - use safe_divide()
- Line 172: `let x_std = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 180: `let is_df1_1 = (self.dfn - T::one()).abs() < T::from(0.001).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 181: `let is_df1_2 = (self.dfn - T::from(2.0).unwrap()).abs() < T::from(0.001).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 182: `let is_df1_5 = (self.dfn - T::from(5.0).unwrap()).abs() < T::from(0.001).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `let is_df2_10 = (self.dfd - T::from(10.0).unwrap()).abs() < T::from(0.001).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 184: `let is_df2_20 = (self.dfd - T::from(20.0).unwrap()).abs() < T::from(0.001).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 185: `let is_x_1 = (x_std - T::one()).abs() < T::from(0.001).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 188: `return T::from(0.6589).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 192: `return T::from(0.5984).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 196: `return T::from(0.175).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 203: `let two = T::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 205: `let dfn_half = self.dfn / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 206: `let dfd_half = self.dfd / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 209: `let z = self.dfn * x_std / (self.dfn * x_std + self.dfd);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 243: `let sample = T::from(std_sample).unwrap() * self.scale + self.loc;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 253: `gamma_function(a) * gamma_function(b) / gamma_function(a + b)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 271: `let epsilon = T::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 276: `let use_symmetry = x > a / (a + b);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 286: `let factor = x.powf(a) * (one - x).powf(b) / (a * beta_function(a, b));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 286: `let factor = x.powf(a) * (one - x).powf(b) / (a * beta_function(a, b));`
  - **Fix**: Mathematical operation .powf( without validation
- Line 293: `let m_t = T::from(m as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 294: `let two_m = T::from((2 * m) as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 300: `let n_even = m_t * (b - m_t) * x / ((a + two_m - one) * (a + two_m));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 301: `d = one / (one + n_even * d_term);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 309: `let n_odd = -(a + m_t) * (a + b + m_t) * x / ((a + two_m) * (a + two_m + one));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 310: `d = one / (one + n_odd * d_term);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 334: `if x == T::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 335: `return T::from(PI).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `T::from(676.5203681218851).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 346: `T::from(-1259.1392167224028).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 347: `T::from(771.323_428_777_653_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 348: `T::from(-176.615_029_162_140_6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 349: `T::from(12.507343278686905).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 350: `T::from(-0.13857109526572012).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 351: `T::from(9.984_369_578_019_572e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 352: `T::from(1.5056327351493116e-7).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 356: `let t = x_adj + T::from(7.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 360: `sum = sum + coef / (x_adj + T::from(i + 1).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 363: `let pi = T::from(PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 364: `let sqrt_2pi = (T::from(2.0).unwrap() * pi).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 366: `sqrt_2pi * sum * t.powf(x_adj + T::from(0.5).unwrap()) * (-t).exp()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 384: `let f_dist = F::new(2.0, 10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 391: `let custom = F::new(5.0, 20.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `let f_dist = F::new(2.0, 10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 424: `let f5_20 = F::new(5.0, 20.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `let f1_10 = F::new(1.0, 10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 445: `let f2_10 = F::new(2.0, 10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 452: `let f5_20 = F::new(5.0, 20.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `let f_dist = F::new(2.0, 10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 464: `let samples = f_dist.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 471: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 481: `assert_relative_eq!(beta_function(2.0, 3.0), 1.0 / 12.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()

### src/distributions/gamma.rs

106 issues found:

- Line 59: `let shape_f64 = <f64 as NumCast>::from(shape).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 60: `let scale_f64 = <f64 as NumCast>::from(scale).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 63: `match RandGamma::new(shape_f64, 1.0 / scale_f64) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 117: `let coef = one / (self.scale.powf(self.shape) * gamma_shape);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 117: `let coef = one / (self.scale.powf(self.shape) * gamma_shape);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 120: `let x_term = x_adj.powf(self.shape - one);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 121: `let exp_term = (-x_adj / self.scale).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 168: `lower_incomplete_gamma_regularized(self.shape, x_adj / self.scale)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 207: `if self.shape == F::from(1.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 210: `let result = -self.scale * (F::one() - p).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 214: `if self.shape == F::from(2.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 216: `if p == F::from(0.5).unwrap() && self.scale == F::one() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 217: `return Ok(F::from(1.678346).unwrap() + self.loc);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 221: `let result = -self.scale * (F::one() - p.sqrt()).ln() * F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 234: `if (cdf_x - p).abs() < F::from(1e-8).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 245: `let delta = (cdf_x - p) / pdf_x;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 250: `x = self.loc + F::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 310: `samples.push(F::from(sample).unwrap() + self.loc);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 320: `let shape_f64 = <f64 as NumCast>::from(self.shape).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 321: `let scale_f64 = <f64 as NumCast>::from(self.scale).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 330: `let rand_distr = RandGamma::new(shape_f64, 1.0 / scale_f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 332: `F::from(sample).unwrap() + loc`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 344: `F::from(676.520_368_121_885_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `F::from(-1_259.139_216_722_403).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 346: `F::from(771.323_428_777_653_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 347: `F::from(-176.615_029_162_140_6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 348: `F::from(12.507_343_278_686_9).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 349: `F::from(-0.138_571_095_265_72).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 350: `F::from(9.984_369_578_019_572e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 351: `F::from(1.505_632_735_149_31e-7).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 355: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 356: `let sqrt_2pi = F::from(2.506_628_274_631).unwrap(); // sqrt(2*pi)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 357: `let g = F::from(7).unwrap(); // Lanczos parameter`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 361: `let sinpx = (F::from(std::f64::consts::PI).unwrap() * x).sin();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 362: `return F::from(std::f64::consts::PI).unwrap() / (sinpx * gamma_fn(one - x));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 369: `let mut acc = F::from(0.999_999_999_999_809_9).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 371: `let i_f = F::from(i).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 372: `acc = acc + coef / (z + i_f + one);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 376: `sqrt_2pi * t.powf(z + half) * (-t).exp() * acc`
  - **Fix**: Mathematical operation .powf( without validation
- Line 384: `let mut term = F::one() / s;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 389: `term = term * x / (s + n);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 392: `if term < F::from(1e-10).unwrap() * sum {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 397: `return sum * (-x).exp() * x.powf(s) / gamma_fn(s);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 397: `return sum * (-x).exp() * x.powf(s) / gamma_fn(s);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 410: `let mut c = F::from(1.0 / 1e-30).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 411: `let mut d = F::one() / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 415: `let i_f = F::from(i).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 417: `a = a + F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 418: `b = b + F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 419: `d = F::one() / (a * d + b);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 420: `c = b + a / c;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 424: `if (del - F::one()).abs() < F::from(1e-10).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 429: `h * (-x).exp() * x.powf(s) / gamma_fn(s)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 429: `h * (-x).exp() * x.powf(s) / gamma_fn(s)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 437: `if shape > F::from(10.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 441: `let sigma = (shape * scale * scale).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 449: `let three = F::from(3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 450: `let nine = F::from(9.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 453: `if (shape - F::from(2.0).unwrap()).abs() < F::from(0.01).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `&& (scale - F::one()).abs() < F::from(0.01).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 455: `&& (p - F::from(0.5).unwrap()).abs() < F::from(0.01).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 457: `return F::from(1.678346).unwrap(); // Exact value for gamma(2,1) at p=0.5`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 462: `let term = one + z * (F::from(2.0).unwrap() / (nine * shape)).sqrt()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 463: `- (F::from(1.0).unwrap() - F::from(2.0).unwrap() / (nine * shape));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 465: `scale * shape * term.powf(three)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 470: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 476: `let t = (-F::from(2.0).unwrap() * p_adj.ln()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 479: `let c0 = F::from(2.515517).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 480: `let c1 = F::from(0.802853).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 481: `let c2 = F::from(0.010328).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 482: `let d1 = F::from(1.432788).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 483: `let d2 = F::from(0.189269).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 484: `let d3 = F::from(0.001308).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 489: `let result = t - numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 501: `if p < F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 507: `F::from(f64::MIN_POSITIVE).unwrap() // Smallest positive float`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 528: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 543: `let ln_gamma_shape = gamma_fn(shape).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 546: `let digamma_shape = if shape > F::from(8.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `shape.ln() - F::one() / (F::from(2.0).unwrap() * shape)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 552: `shape.ln() - F::one() / (shape * F::from(2.0).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 555: `shape + scale.ln() + ln_gamma_shape + (F::one() - shape) * digamma_shape`
  - **Fix**: Mathematical operation .ln() without validation
- Line 593: `let gamma = Gamma::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 599: `let custom = Gamma::new(3.0, 2.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 614: `let exp = Gamma::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 619: `let gamma2 = Gamma::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 625: `let shifted = Gamma::new(2.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 633: `let exp = Gamma::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 639: `let gamma2 = Gamma::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 645: `let shifted = Gamma::new(2.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 653: `let exp = Gamma::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 654: `assert_relative_eq!(exp.ppf(0.5).unwrap(), 0.693147, epsilon = 1e-5);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 655: `assert_relative_eq!(exp.ppf(0.95).unwrap(), 2.995732, epsilon = 1e-5);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 658: `let gamma2 = Gamma::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 659: `assert_relative_eq!(gamma2.ppf(0.5).unwrap(), 1.678346, epsilon = 1e-5);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 662: `let shifted = Gamma::new(2.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 663: `assert_relative_eq!(shifted.ppf(0.5).unwrap(), 2.678346, epsilon = 1e-5);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 672: `let gamma = Gamma::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 675: `let samples_vec = gamma.rvs_vec(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 679: `let samples_array = gamma.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 684: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 694: `/ 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 720: `let gamma = Gamma::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 728: `let samples = gamma.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 738: `let gamma = Gamma::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 750: `assert_relative_eq!(dist.ppf(0.5).unwrap(), 1.678346, epsilon = 1e-5);`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/geometric.rs

43 issues found:

- Line 49: `let p_f64 = <f64 as num_traits::NumCast>::from(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 90: `let k_usize = k.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 94: `self.p * q.powf(F::from(k_usize).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 125: `let k_usize = k.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 126: `let k_f = F::from(k_usize).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 132: `self.p.ln() + k_f * q.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 165: `let k_int = k_floor.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 169: `one - q.powf(F::from(k_int + 1).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 253: `let sample_f = F::from(sample).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 279: `q / self.p`
  - **Fix**: Division without zero check - use safe_divide()
- Line 301: `q / (self.p * self.p)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 321: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 342: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `(two - self.p) / q.sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 345: `(two - self.p) / q.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 366: `let six = F::from(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 369: `six + (self.p * self.p) / q`
  - **Fix**: Division without zero check - use safe_divide()
- Line 392: `-(q * q.ln() + self.p * self.p.ln()) / self.p`
  - **Fix**: Division without zero check - use safe_divide()
- Line 392: `-(q * q.ln() + self.p * self.p.ln()) / self.p`
  - **Fix**: Mathematical operation .ln() without validation
- Line 412: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 416: `(half.ln() / q.ln()).ceil() - one`
  - **Fix**: Division without zero check - use safe_divide()
- Line 416: `(half.ln() / q.ln()).ceil() - one`
  - **Fix**: Mathematical operation .ln() without validation
- Line 489: `let geom1 = Geometric::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 492: `let geom2 = Geometric::new(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 504: `let geom = Geometric::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 519: `let geom_p1 = Geometric::new(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 528: `let geom = Geometric::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 537: `assert_relative_eq!(log_pmf, pmf.ln(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 551: `let geom = Geometric::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 572: `let geom_p1 = Geometric::new(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 580: `let geom = Geometric::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `assert_eq!(geom.ppf(p_mid).unwrap(), k_f);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 595: `assert_eq!(geom.ppf(cdf_k / 2.0).unwrap(), k_f);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 600: `assert_eq!(geom.ppf(0.0).unwrap(), 0.0);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 601: `assert!(geom.ppf(1.0).unwrap().is_infinite()); // For p=1, the result should be ...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 606: `let k = geom.ppf(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 634: `let geom = Geometric::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 637: `let samples = geom.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 650: `let mean = sum / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 659: `let geom = Geometric::new(0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 690: `let geom_p1 = Geometric::new(1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 707: `assert_eq!(geom_p1.ppf(0.5).unwrap(), 0.0);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 708: `assert!(geom_p1.ppf(1.0).unwrap().is_infinite());`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/hypergeometric.rs

25 issues found:

- Line 198: `cdf_value = cdf_value + self.pmf(F::from(k).unwrap() + self.loc);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 232: `let p_success = success_remaining as f64 / population_remaining as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 243: `samples[i] = F::from(successes).unwrap() + self.loc;`
  - **Fix**: Use .get() with proper bounds checking
- Line 255: `let mean_val = (self.n_draws as f64) * (self.n_success as f64) / (self.n_populat...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 256: `F::from(mean_val).unwrap() + self.loc`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 273: `let p = k / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 274: `let variance = n_draws * p * (1.0 - p) * (n - n_draws) / (n - 1.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 276: `F::from(variance).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 285: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 303: `let ln_n_fact = (1..=n).map(|i| (i as f64).ln()).sum::<f64>();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 304: `let ln_k_fact = (1..=k).map(|i| (i as f64).ln()).sum::<f64>();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 305: `let ln_n_minus_k_fact = (1..=(n - k)).map(|i| (i as f64).ln()).sum::<f64>();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 360: `let hyper = Hypergeometric::new(20, 7, 12, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 375: `let hyper = Hypergeometric::new(20, 7, 12, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 389: `let shifted_hyper = Hypergeometric::new(20, 7, 12, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 402: `let hyper = Hypergeometric::new(20, 7, 12, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 415: `let shifted_hyper = Hypergeometric::new(20, 7, 12, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 428: `let hyper = Hypergeometric::new(20, 7, 12, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 442: `let shifted_hyper = Hypergeometric::new(20, 7, 12, 3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 451: `let hyper = Hypergeometric::<f64>::new(100, 40, 20, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `let samples = hyper.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 467: `let mean = samples.sum() / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 474: `let hyper_no_success = Hypergeometric::new(20, 0, 10, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 481: `let hyper_no_draws = Hypergeometric::new(20, 10, 0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 488: `let hyper_all_success = Hypergeometric::new(20, 20, 10, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/laplace.rs

36 issues found:

- Line 90: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 98: `half / self.scale * (-abs_value / self.scale).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 121: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 125: `half * ((x - self.loc) / self.scale).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 128: `F::one() - half * (-(x - self.loc) / self.scale).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 158: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 162: `self.loc + self.scale * (p + p).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 165: `self.loc - self.scale * ((F::one() - p) + (F::one() - p)).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 197: `let u_f = F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 211: `let u_f = F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 285: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 306: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 386: `F::from(3.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 407: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 408: `one + (two * self.scale).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 495: `let laplace = Laplace::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 500: `let custom = Laplace::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 512: `let laplace = Laplace::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 527: `let custom = Laplace::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 541: `let laplace = Laplace::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 556: `let custom = Laplace::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 570: `let laplace = Laplace::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 573: `let ppf_at_half = laplace.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 577: `let ppf_at_75 = laplace.ppf(0.75).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 581: `let ppf_at_25 = laplace.ppf(0.25).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 585: `let custom = Laplace::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 588: `let ppf_at_half_custom = custom.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `let ppf_at_75_custom = custom.ppf(0.75).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 603: `let laplace = Laplace::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 638: `let custom = Laplace::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 659: `let laplace = Laplace::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 662: `let samples = laplace.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 670: `let mean = sum / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 679: `let laplace = Laplace::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 684: `let x = laplace.ppf(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 693: `let x_back = laplace.ppf(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/logistic.rs

37 issues found:

- Line 88: `let z = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 92: `exp_neg_z / (self.scale * (F::one() + exp_neg_z).powi(2))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 115: `let z = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 118: `F::one() / (F::one() + (-z).exp())`
  - **Fix**: Division without zero check - use safe_divide()
- Line 156: `let quantile = self.loc + self.scale * (p / (F::one() - p)).ln();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 156: `let quantile = self.loc + self.scale * (p / (F::one() - p)).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 191: `let u_f = F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 209: `let u_f = F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 259: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 261: `let one_third = F::from(1.0 / 3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 283: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 363: `F::from(1.2).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 383: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 384: `two + self.scale.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 404: `let three = F::from(3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `self.scale * three.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 454: `let logistic = Logistic::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `let custom = Logistic::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 471: `let logistic = Logistic::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 486: `let custom = Logistic::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 496: `let logistic = Logistic::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 511: `let custom = Logistic::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 525: `let logistic = Logistic::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 528: `let ppf_at_half = logistic.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 532: `let ppf_at_75 = logistic.ppf(0.75).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 536: `let ppf_at_25 = logistic.ppf(0.25).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 540: `let custom = Logistic::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 543: `let ppf_at_half_custom = custom.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 547: `let ppf_at_75_custom = custom.ppf(0.75).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 558: `let logistic = Logistic::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 597: `let custom = Logistic::new(-2.0, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 614: `let logistic = Logistic::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `let samples = logistic.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 624: `let mean = sum / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 633: `let logistic = Logistic::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 638: `let x = logistic.ppf(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 647: `let x_back = logistic.ppf(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/lognormal.rs

26 issues found:

- Line 94: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 95: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `let ln_x = x_shifted.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 98: `let z = (ln_x - self.mu) / self.sigma;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 99: `let exponent = -z * z / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 101: `F::from(1.0).unwrap() / (x_shifted * self.sigma * (two * pi).sqrt()) * exponent....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `let ln_x = x_shifted.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 226: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 249: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 339: `let lognorm = Lognormal::new(0.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `let custom = Lognormal::new(1.0, 0.5, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 358: `let lognorm = Lognormal::new(0.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 377: `let custom = Lognormal::new(1.0, 0.5, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 391: `let lognorm = Lognormal::new(0.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 413: `let lognorm = Lognormal::new(0.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 416: `let median = lognorm.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 420: `let p75 = lognorm.ppf(0.75).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 424: `let p25 = lognorm.ppf(0.25).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 435: `let lognorm = Lognormal::new(0.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `let custom = Lognormal::new(1.0, 0.5, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 458: `let expected_mean = (1.0 + 0.5 * 0.5 / 2.0).exp() + 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 468: `let lognorm = Lognormal::new(0.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 471: `let samples = lognorm.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 483: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 491: `sorted_samples.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 493: `(sorted_samples[499] + sorted_samples[500]) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()

### src/distributions/multivariate/dirichlet.rs

24 issues found:

- Line 28: `result += (i as f64).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 35: `return (std::f64::consts::PI.sqrt()).ln();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 35: `return (std::f64::consts::PI.sqrt()).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 40: `return (x - 1.0).ln() + lgamma(x - 1.0);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 45: `return (std::f64::consts::PI / (std::f64::consts::PI * x).sin()).ln() - lgamma(1...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 45: `return (std::f64::consts::PI / (std::f64::consts::PI * x).sin()).ln() - lgamma(1...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 65: `sum += coef / (x_adj + (i + 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 69: `let sqrt_2pi = (2.0 * pi).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 71: `sqrt_2pi.ln() + sum.ln() + (x_adj + 0.5) * t.ln() - t`
  - **Fix**: Mathematical operation .ln() without validation
- Line 244: `log_pdf += (self.alpha[i] - 1.0) * x[i].ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 297: `sample.mapv_inplace(|x| x / sum);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 376: `let dirichlet = Dirichlet::new(alpha.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 383: `let dirichlet2 = Dirichlet::new(alpha2.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 405: `let dirichlet = Dirichlet::new(alpha).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 407: `let point1 = array![1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 415: `let concentrated = Dirichlet::new(alpha).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 418: `let center = array![1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 427: `let dirichlet = Dirichlet::new(alpha).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 444: `let dirichlet = Dirichlet::new(alpha).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 462: `let dirichlet = Dirichlet::new(alpha.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 466: `let samples = dirichlet.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 493: `let expected_mean = alpha[i] / alpha_sum;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 501: `let dirichlet = Dirichlet::new(alpha.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 503: `let sample = dirichlet.rvs_single().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/multivariate/inverse_wishart.rs

15 issues found:

- Line 174: `let term2 = -0.5 * self.scale_det.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 175: `let term3 = -0.5 * p * (2.0f64).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 177: `let term5 = -0.5 * (n + p + 1.0) * x_det.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 413: `let inv_wishart = InverseWishart::new(scale.clone(), df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 422: `let inv_wishart3 = InverseWishart::new(scale3.clone(), df3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 448: `let inv_wishart = InverseWishart::new(scale.clone(), df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 450: `let mean = inv_wishart.mean().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 464: `let inv_wishart = InverseWishart::new(scale.clone(), df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 481: `let inv_wishart = InverseWishart::new(scale, df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 502: `let inv_wishart = InverseWishart::new(scale, df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 519: `let inv_wishart = InverseWishart::new(scale.clone(), df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 523: `let samples = inv_wishart.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 541: `let expected_mean = scale.clone() / (df - 3.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 560: `let inv_wishart = InverseWishart::new(scale, df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 562: `let sample = inv_wishart.rvs_single().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/multivariate/multinomial.rs

15 issues found:

- Line 34: `factorial(n) / denominator`
  - **Fix**: Division without zero check - use safe_divide()
- Line 166: `product *= self.p[i].powf(count as f64);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 231: `let log_coef = factorial(self.n).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 234: `log_denom += factorial(count).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 241: `log_prob_sum += (count as f64) * self.p[i].ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 435: `let multinomial = Multinomial::new(n, p.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 452: `let multinomial = Multinomial::new(n, p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 490: `let multinomial = Multinomial::new(n, p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 510: `let multinomial = Multinomial::new(n, p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 524: `let multinomial = Multinomial::new(n, p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 553: `let multinomial = Multinomial::new(n, p.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 557: `let samples = multinomial.rvs(num_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 576: `let sample_mean = sample_sum / num_samples as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 592: `let multinomial = Multinomial::new(n, p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 594: `let sample = multinomial.rvs_single().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/multivariate/multivariate_lognormal.rs

18 issues found:

- Line 111: `let log_x = x.mapv(|xi| xi.ln());`
  - **Fix**: Mathematical operation .ln() without validation
- Line 119: `normal_pdf / jacobian_factor`
  - **Fix**: Division without zero check - use safe_divide()
- Line 161: `let log_x = x.mapv(|xi| xi.ln());`
  - **Fix**: Mathematical operation .ln() without validation
- Line 167: `let sum_log_x = x.iter().fold(0.0, |acc, &xi| acc + xi.ln());`
  - **Fix**: Mathematical operation .ln() without validation
- Line 259: `mean[i] = (self.mu[i] + self.sigma[[i, i]] / 2.0).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 353: `let mean_i = (self.mu[i] + self.sigma[[i, i]] / 2.0).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 354: `let mean_j = (self.mu[j] + self.sigma[[j, j]] / 2.0).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 442: `let mvln = MultivariateLognormal::new(mu.clone(), sigma.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 451: `let mvln3 = MultivariateLognormal::new(mu3.clone(), sigma3.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 476: `let mvln = MultivariateLognormal::new(mu, sigma).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 504: `let mvln = MultivariateLognormal::new(mu, sigma).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 523: `let mvln = MultivariateLognormal::new(mu, sigma).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 527: `let expected_mean = array![(0.5_f64 / 2.0).exp(), (0.5_f64 / 2.0).exp()];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 548: `let mean_i = (0.5_f64 / 2.0).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 564: `let mvln = MultivariateLognormal::new(mu, sigma).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 568: `let samples = mvln.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 580: `let sample_mean = samples.mean_axis(Axis(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 586: `let single_sample = mvln.rvs_single().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/multivariate/normal.rs

28 issues found:

- Line 134: `let constant_factor = 1.0 / ((two * pi).powf(self.dim as f64 / two) * self.cov_d...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 134: `let constant_factor = 1.0 / ((two * pi).powf(self.dim as f64 / two) * self.cov_d...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 134: `let constant_factor = 1.0 / ((two * pi).powf(self.dim as f64 / two) * self.cov_d...`
  - **Fix**: Mathematical operation .powf( without validation
- Line 141: `constant_factor * (-mahalanobis_squared / two).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 175: `let normal = RandNormal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `let log_const = -(self.dim as f64) / two * (two * pi).ln() - self.cov_det.ln() /...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 269: `let log_const = -(self.dim as f64) / two * (two * pi).ln() - self.cov_det.ln() /...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 276: `log_const - mahalanobis_squared / two`
  - **Fix**: Division without zero check - use safe_divide()
- Line 314: `l[[j, j]] = diag_value.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 320: `l[[i, j]] = (a[[i, j]] - sum) / l[[j, j]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 338: `l_inv[[i, i]] = 1.0 / l[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 348: `l_inv[[i, j]] = -sum / l[[i, i]];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 425: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 439: `k / 2.0 + k / 2.0 * (2.0 * pi).ln() + 0.5 * self.cov_det.ln()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 439: `k / 2.0 + k / 2.0 * (2.0 * pi).ln() + 0.5 * self.cov_det.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 497: `let mvn = MultivariateNormal::new(mean.clone(), cov.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 506: `let mvn3 = MultivariateNormal::new(mean3.clone(), cov3.clone()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 531: `let mvn = MultivariateNormal::new(mean, cov).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 547: `let mvn = MultivariateNormal::new(mean, cov).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 565: `let mvn = MultivariateNormal::new(mean, cov).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 569: `let samples = mvn.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 573: `let sample_mean = samples.mean_axis(Axis(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 579: `let sample_cov = centered.t().dot(&centered) / (n_samples as f64 - 1.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 589: `let mvn = MultivariateNormal::new(mean, cov).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 591: `let sample = mvn.rvs_single().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 600: `let l = compute_cholesky(&a).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 626: `let l = compute_cholesky(&a).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 629: `let a_inv = compute_inverse_from_cholesky(&l).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/multivariate/student_t.rs

42 issues found:

- Line 30: `result += (i as f64).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 37: `return (std::f64::consts::PI.sqrt()).ln();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 37: `return (std::f64::consts::PI.sqrt()).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 42: `return (x - 1.0).ln() + lgamma(x - 1.0);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 47: `return (std::f64::consts::PI / (std::f64::consts::PI * x).sin()).ln() - lgamma(1...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 47: `return (std::f64::consts::PI / (std::f64::consts::PI * x).sin()).ln() - lgamma(1...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 67: `sum += coef / (x_adj + (i + 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 71: `let sqrt_2pi = (2.0 * pi).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 73: `sqrt_2pi.ln() + sum.ln() + (x_adj + 0.5) * t.ln() - t`
  - **Fix**: Mathematical operation .ln() without validation
- Line 213: `let gamma_term_num = lgamma((self.df + self.dim as f64) / 2.0).exp();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 214: `let gamma_term_denom = lgamma(self.df / 2.0).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 215: `* lgamma(self.dim as f64 / 2.0).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 216: `* self.df.powf(self.dim as f64 / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 216: `* self.df.powf(self.dim as f64 / 2.0);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 218: `/ (gamma_term_denom * pi.powf(self.dim as f64 / 2.0) * self.scale_det.sqrt());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 218: `/ (gamma_term_denom * pi.powf(self.dim as f64 / 2.0) * self.scale_det.sqrt());`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 218: `/ (gamma_term_denom * pi.powf(self.dim as f64 / 2.0) * self.scale_det.sqrt());`
  - **Fix**: Mathematical operation .powf( without validation
- Line 227: `* (1.0 + mahalanobis_squared / self.df).powf(-(self.df + self.dim as f64) / 2.0)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 227: `* (1.0 + mahalanobis_squared / self.df).powf(-(self.df + self.dim as f64) / 2.0)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 261: `let normal_dist = RandNormal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 262: `let chi2_dist = ChiSquared::new(self.df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 287: `let scaling_factor = (self.df / w).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 287: `let scaling_factor = (self.df / w).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 353: `let gamma_term_num = lgamma((self.df + self.dim as f64) / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 354: `let gamma_term_denom = lgamma(self.df / 2.0)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 355: `+ lgamma(self.dim as f64 / 2.0)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 356: `+ (self.dim as f64 / 2.0) * self.df.ln();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 356: `+ (self.dim as f64 / 2.0) * self.df.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 359: `- (self.dim as f64 / 2.0) * pi.ln()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 359: `- (self.dim as f64 / 2.0) * pi.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 360: `- 0.5 * self.scale_det.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 367: `log_const - ((self.df + self.dim as f64) / 2.0) * (1.0 + mahalanobis_squared / s...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 367: `log_const - ((self.df + self.dim as f64) / 2.0) * (1.0 + mahalanobis_squared / s...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 455: `let mvt = MultivariateT::new(mean.clone(), scale.clone(), 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 465: `let mvt3 = MultivariateT::new(mean3.clone(), scale3.clone(), 10.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 497: `let mvt = MultivariateT::new(mean, scale, 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 518: `let mvt = MultivariateT::new(mean, scale, 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 532: `let mvt = MultivariateT::new(mean, scale, 10.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 536: `let samples = mvt.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 540: `let sample_mean = samples.mean_axis(Axis(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 549: `let mvt = MultivariateT::new(mean, scale, 5.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 551: `let sample = mvt.rvs_single().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/multivariate/wishart.rs

29 issues found:

- Line 30: `result += (i as f64).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 37: `return (std::f64::consts::PI.sqrt()).ln();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 37: `return (std::f64::consts::PI.sqrt()).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 42: `return (x - 1.0).ln() + lgamma(x - 1.0);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 47: `return (std::f64::consts::PI / (std::f64::consts::PI * x).sin()).ln() - lgamma(1...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 47: `return (std::f64::consts::PI / (std::f64::consts::PI * x).sin()).ln() - lgamma(1...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 67: `sum += coef / (x_adj + (i + 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 71: `let sqrt_2pi = (2.0 * pi).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 73: `sqrt_2pi.ln() + sum.ln() + (x_adj + 0.5) * t.ln() - t`
  - **Fix**: Mathematical operation .ln() without validation
- Line 85: `let term1 = (p * (p - 1)) as f64 / 4.0 * pi.ln();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 85: `let term1 = (p * (p - 1)) as f64 / 4.0 * pi.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 90: `let arg = (n + 1.0 - i as f64) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 252: `let term2 = -0.5 * n * self.scale_det.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 253: `let term3 = -0.5 * p * (2.0f64).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 255: `let term5 = 0.5 * (n - p - 1.0) * x_det.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 329: `let normal_dist = RandNormal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 373: `a[[i, i]] = chi2_dist.sample(&mut rng).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 539: `let wishart = Wishart::new(scale.clone(), df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `let wishart3 = Wishart::new(scale3.clone(), df3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 574: `let wishart = Wishart::new(scale.clone(), df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 590: `let wishart = Wishart::new(scale.clone(), df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `let mode = wishart.mode().unwrap(); // Mode should exist`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 602: `let wishart2 = Wishart::new(scale, 2.5).unwrap(); // df = 2.5 < p + 1 = 3`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 611: `let wishart = Wishart::new(scale, df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 632: `let wishart = Wishart::new(scale, df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 649: `let wishart = Wishart::new(scale.clone(), df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 653: `let samples = wishart.rvs(n_samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 690: `let wishart = Wishart::new(scale, df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 692: `let sample = wishart.rvs_single().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/negative_binomial.rs

78 issues found:

- Line 91: `let k_usize = k.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 92: `let k_f = F::from(k_usize).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 102: `let r_usize = self.r.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 116: `let k_f = F::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 118: `let r_usize = self.r.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 119: `let r_f = F::from(r_usize).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 125: `let p_pow_r = self.p.powf(r_f);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 126: `let q_pow_k = (one - self.p).powf(k_f);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 136: `let k_f64 = <f64 as num_traits::NumCast>::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 137: `let r_f64 = <f64 as num_traits::NumCast>::from(self.r).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 143: `let p_f64 = <f64 as num_traits::NumCast>::from(self.p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 144: `let ln_prob = r_f64 * p_f64.ln() + k_f64 * (1.0 - p_f64).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 147: `F::from((ln_coef + ln_prob).exp()).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 179: `let k_usize = k.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 180: `let k_f = F::from(k_usize).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 189: `let r_usize = self.r.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 202: `let k_f = F::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 204: `let r_usize = self.r.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 205: `let r_f = F::from(r_usize).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 211: `let ln_p_pow_r = r_f * self.p.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 212: `let ln_q_pow_k = k_f * (one - self.p).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 222: `let k_f64 = <f64 as num_traits::NumCast>::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 223: `let r_f64 = <f64 as num_traits::NumCast>::from(self.r).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 229: `let p_f64 = <f64 as num_traits::NumCast>::from(self.p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 230: `let ln_prob = r_f64 * p_f64.ln() + k_f64 * (1.0 - p_f64).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 233: `F::from(ln_coef + ln_prob).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 271: `let k_int = k_floor.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 276: `sum = sum + self.pmf(F::from(i).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 371: `let r_usize = self.r.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `let p_f64 = <f64 as num_traits::NumCast>::from(self.p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 380: `let geom_sample = (u.ln() / (1.0 - p_f64).ln()).floor() as usize;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 380: `let geom_sample = (u.ln() / (1.0 - p_f64).ln()).floor() as usize;`
  - **Fix**: Mathematical operation .ln() without validation
- Line 383: `samples.push(F::from(sum).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 387: `let r_f64 = <f64 as num_traits::NumCast>::from(self.r).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 388: `let p_f64 = <f64 as num_traits::NumCast>::from(self.p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 393: `rand_distr::Gamma::new(r_f64, (1.0 - p_f64) / p_f64).map_err(|_| {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 408: `samples.push(F::from(poisson_sample).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 434: `self.r * q / self.p`
  - **Fix**: Division without zero check - use safe_divide()
- Line 456: `self.r * q / (self.p * self.p)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 476: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 497: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 500: `(two - self.p) / (self.r * q).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 500: `(two - self.p) / (self.r * q).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 521: `let six = F::from(6.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 524: `six / self.r + (self.p * self.p) / (self.r * q)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 545: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 546: `let two_pi_e = F::from(2.0 * std::f64::consts::PI * std::f64::consts::E).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 549: `if self.r >= F::from(10.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 551: `return half * (two_pi_e * variance).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 562: `return self.r * (-self.p.ln()) - mean * q.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 566: `half * (two_pi_e * self.var()).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 595: `((self.r - one) * q / self.p).floor()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 609: `result = result * (n - i) as u64 / (i + 1) as u64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 611: `F::from(result).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 626: `F::from(result).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 675: `let nb1 = NegativeBinomial::new(5.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 679: `let nb2 = NegativeBinomial::new(1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 696: `let nb = NegativeBinomial::new(5.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 711: `let nb_geom = NegativeBinomial::new(1.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 717: `let nb_p1 = NegativeBinomial::new(5.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 722: `let nb_non_int = NegativeBinomial::new(2.5, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 730: `let nb = NegativeBinomial::new(5.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 739: `assert_relative_eq!(log_pmf, pmf.ln(), epsilon = 1e-5);`
  - **Fix**: Mathematical operation .ln() without validation
- Line 753: `let nb = NegativeBinomial::new(5.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 768: `let nb_p1 = NegativeBinomial::new(5.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 776: `let nb = NegativeBinomial::new(5.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 781: `let k = nb.ppf(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 797: `assert_eq!(nb.ppf(0.0).unwrap(), 0.0);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 798: `assert!(nb.ppf(1.0).unwrap().is_infinite());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 808: `let nb = NegativeBinomial::new(5.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 811: `let samples = nb.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 824: `let mean = sum / samples.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 833: `let nb = NegativeBinomial::new(5.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 857: `let nb_geom = NegativeBinomial::new(1.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 869: `let nb_large = NegativeBinomial::new(100.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 875: `let nb_p_high = NegativeBinomial::new(5.0, 0.99).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 884: `let nb_int = NegativeBinomial::new(5.0, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 903: `let nb_non_int = NegativeBinomial::new(2.5, 0.3).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/normal.rs

51 issues found:

- Line 47: `let loc_f64 = <f64 as NumCast>::from(loc).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 48: `let scale_f64 = <f64 as NumCast>::from(scale).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 81: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 82: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 84: `let z = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 85: `let exponent = -z * z / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 87: `F::from(1.0).unwrap() / (self.scale * (two * pi).sqrt()) * exponent.exp()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 111: `let z = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 115: `return F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 120: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 124: `half * (one + erf(z / two.sqrt()))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 124: `half * (one + erf(z / two.sqrt()))`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 164: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 167: `let c0 = F::from(2.515517).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 168: `let c1 = F::from(0.802853).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 169: `let c2 = F::from(0.010328).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 170: `let d1 = F::from(1.432788).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 171: `let d2 = F::from(0.189269).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 172: `let d3 = F::from(0.001308).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 177: `let t = (-F::from(2.0).unwrap() * q.ln()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 178: `-t + (c0 + c1 * t + c2 * t * t) / (F::one() + d1 * t + d2 * t * t + d3 * t * t *...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 182: `let t = (-F::from(2.0).unwrap() * q.ln()).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `t - (c0 + c1 * t + c2 * t * t) / (F::one() + d1 * t + d2 * t * t + d3 * t * t * ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 215: `samples.push(F::from(sample).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 234: `let a1 = F::from(0.254829592).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 235: `let a2 = F::from(-0.284496736).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 236: `let a3 = F::from(1.421413741).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 237: `let a4 = F::from(-1.453152027).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 238: `let a5 = F::from(1.061405429).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 239: `let p = F::from(0.3275911).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 242: `let t = one / (one + p * x);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 268: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 270: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 271: `let e = F::from(std::f64::consts::E).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 273: `half + half * (two * pi * e * self.scale * self.scale).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 308: `let norm = Normal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 313: `let custom = Normal::new(5.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 325: `let norm = Normal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 340: `let custom = Normal::new(5.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 347: `let norm = Normal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 365: `let norm = Normal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 368: `let median = norm.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 372: `let p975 = norm.ppf(0.975).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 376: `let p025 = norm.ppf(0.025).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 386: `let norm = Normal::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 389: `let samples = norm.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 396: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 406: `/ 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 407: `let std_dev = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation

### src/distributions/pareto.rs

38 issues found:

- Line 107: `let ratio = self.scale / x_adjusted;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 109: `self.shape / self.scale * ratio.powf(shape_plus_one)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 109: `self.shape / self.scale * ratio.powf(shape_plus_one)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 141: `let ratio = self.scale / x_adjusted;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 142: `F::one() - ratio.powf(self.shape)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 183: `let pow = one_minus_p.powf(one / self.shape);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 183: `let pow = one_minus_p.powf(one / self.shape);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 184: `let quantile = self.scale / pow + self.loc;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 216: `let u_f = F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 249: `(self.shape * self.scale) / shape_minus_one + self.loc`
  - **Fix**: Division without zero check - use safe_divide()
- Line 269: `if self.shape <= F::from(2.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 275: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 280: `/ (shape_minus_one * shape_minus_one * shape_minus_two)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 300: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 301: `let two_pow = two.powf(F::one() / self.shape);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 301: `let two_pow = two.powf(F::one() / self.shape);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 372: `let pareto1 = Pareto::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 378: `let pareto3 = Pareto::new(3.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 384: `let custom = Pareto::new(2.5, 2.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 399: `let pareto = Pareto::new(3.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 414: `let custom = Pareto::new(3.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 428: `let pareto = Pareto::new(3.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `let custom = Pareto::new(3.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 457: `let pareto = Pareto::new(3.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 460: `let ppf_at_zero = pareto.ppf(0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 464: `let ppf_at_half = pareto.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 468: `let ppf_at_875 = pareto.ppf(0.875).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 472: `let custom = Pareto::new(3.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 475: `let ppf_at_half_loc = custom.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 486: `let pareto = Pareto::new(3.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 506: `let pareto1 = Pareto::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 511: `let pareto15 = Pareto::new(1.5, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 516: `let custom = Pareto::new(3.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 529: `let pareto = Pareto::new(3.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 532: `let samples = pareto.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 544: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 552: `sorted_samples.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 554: `(sorted_samples[499] + sorted_samples[500]) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()

### src/distributions/poisson.rs

33 issues found:

- Line 50: `let mu_f64 = <f64 as NumCast>::from(mu).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 93: `let k_int = <u64 as NumCast>::from(k_std).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `let mu_pow_k = self.mu.powf(k_std);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 101: `mu_pow_k * exp_neg_mu / F::from(k_factorial).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 134: `let k_int = <u64 as NumCast>::from(k_floor).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 137: `if self.mu == F::from(3.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 139: `return F::from(0.423).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 141: `return F::from(0.815).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 148: `let i_f = F::from(i).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `let shifted_sample = F::from(sample).unwrap() + self.loc;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 193: `(x - x.round()).abs() < F::from(1e-10).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 207: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 216: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 217: `let two_pi = F::from(2.0 * std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 218: `let e = F::from(std::f64::consts::E).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 224: `half * (two_pi * e * self.mu).ln() - half / (F::from(12.0).unwrap() * self.mu)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 257: `let k_int = <u64 as NumCast>::from(k_std).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 260: `let k_f = F::from(k_int).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 261: `k_f * self.mu.ln() - self.mu - ln_factorial(k_int)`
  - **Fix**: Mathematical operation .ln() without validation
- Line 273: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 274: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 275: `let e = F::from(std::f64::consts::E).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 277: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 278: `return half * (F::from(2.0).unwrap() * pi * n_f).ln() + n_f * (n_f / e).ln();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 282: `F::from((factorial(n) as f64).ln()).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 301: `if result > u64::MAX / i {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 319: `let poisson = Poisson::new(3.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 324: `let custom = Poisson::new(5.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 336: `let poisson = Poisson::new(3.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 362: `let poisson = Poisson::new(3.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 387: `let poisson = Poisson::new(3.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 390: `let samples = poisson.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 397: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()

### src/distributions/student_t.rs

103 issues found:

- Line 60: `let df_f64 = <f64 as NumCast>::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `let x_std = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 100: `let df_half = self.df / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 101: `let df_plus_one_half = (self.df + F::one()) / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `let pi = F::from(PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 109: `let denominator = gamma_function(df_half) * (self.df * pi).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 111: `let factor = numerator / denominator / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 112: `let exponent = -(df_plus_one_half) * (one + x_std * x_std / self.df).ln();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 112: `let exponent = -(df_plus_one_half) * (one + x_std * x_std / self.df).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 139: `let x_std = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 143: `return F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 158: `if (self.df - F::from(5.0).unwrap()).abs() < F::from(0.001).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 163: `if (x_std - F::from(val).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 164: `return F::from(prob).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 171: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 175: `half + (x_std / self.df.sqrt()).atan() * F::from(std::f64::consts::FRAC_1_PI).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 178: `half - ((-x_std) / self.df.sqrt()).atan()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 178: `half - ((-x_std) / self.df.sqrt()).atan()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 179: `* F::from(std::f64::consts::FRAC_1_PI).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 239: `let sample = F::from(std_sample).unwrap() * self.scale + self.loc;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 250: `let df_f64 = <f64 as NumCast>::from(self.df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 260: `let rand_distr = RandStudentT::new(df_f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 262: `F::from(sample).unwrap() * scale + loc`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 276: `if x == F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 277: `return F::from(PI).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 287: `F::from(676.5203681218851).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 288: `F::from(-1259.1392167224028).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 289: `F::from(771.323_428_777_653_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 290: `F::from(-176.615_029_162_140_6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 291: `F::from(12.507343278686905).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 292: `F::from(-0.13857109526572012).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 293: `F::from(9.984_369_578_019_572e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 294: `F::from(1.5056327351493116e-7).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 298: `let t = x_adj + F::from(7.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 302: `sum = sum + coef / (x_adj + F::from(i + 1).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 305: `let pi = F::from(PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 306: `let sqrt_2pi = (F::from(2.0).unwrap() * pi).sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 308: `sqrt_2pi * sum * t.powf(x_adj + F::from(0.5).unwrap()) * (-t).exp()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 328: `let epsilon = F::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 333: `let factor = (gamma_function(a + b) / (gamma_function(a) * gamma_function(b)))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 334: `* x.powf(a)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 335: `* (one - x).powf(b)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 336: `/ a;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 344: `let two_m = F::from((2 * m) as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 351: `let term1 = a_term / b_term;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 353: `d = one / (one + term1 * d);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 362: `factor / a * h`
  - **Fix**: Division without zero check - use safe_divide()
- Line 379: `if self.df <= F::from(2.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 382: `self.df / (self.df - F::from(2.0).unwrap()) * self.scale * self.scale`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 388: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 399: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 407: `if df > F::from(1000.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 408: `let e = F::from(std::f64::consts::E).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 410: `* (F::from(2.0).unwrap() * F::from(std::f64::consts::PI).unwrap() * e).ln()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 411: `+ self.scale.ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 418: `let term1 = half_df_plus_half * (gamma_function(half) / gamma_function(half_df))...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 418: `let term1 = half_df_plus_half * (gamma_function(half) / gamma_function(half_df))...`
  - **Fix**: Mathematical operation .ln() without validation
- Line 420: `let term3 = half * (df * F::from(std::f64::consts::PI).unwrap()).ln();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `if p == F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `if (self.df - F::from(5.0).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 460: `if (p - F::from(0.95).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `return Ok(self.loc + F::from(2.0).unwrap() * self.scale);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 463: `if (p - F::from(0.975).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 464: `return Ok(self.loc + F::from(2.571).unwrap() * self.scale);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 466: `if (p - F::from(0.05).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 467: `return Ok(self.loc - F::from(2.0).unwrap() * self.scale);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 469: `if (p - F::from(0.025).unwrap()).abs() < F::from(0.001).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 470: `return Ok(self.loc - F::from(2.571).unwrap() * self.scale);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 475: `if self.df > F::from(30.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `let z = if p > F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 478: `(-(F::one() - p).ln()).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 478: `(-(F::one() - p).ln()).sqrt()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 480: `-(-(p).ln()).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 480: `-(-(p).ln()).sqrt()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 486: `let sign = if p > F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 491: `let p_adj = if p > F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 498: `let factor = if self.df < F::from(3.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 499: `F::from(1.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 500: `} else if self.df < F::from(10.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 501: `F::from(1.2).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 503: `F::from(1.1).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 506: `let t_value = sign * factor * (-F::from(2.0).unwrap() * (F::one() - p_adj).ln())...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 527: `let t5 = StudentT::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 533: `let custom = StudentT::new(10.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `let t5 = StudentT::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 566: `let t5 = StudentT::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `let t5 = StudentT::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 587: `let median = t5.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 591: `let p95 = t5.ppf(0.95).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 595: `let p05 = t5.ppf(0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 601: `let t5 = StudentT::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 604: `let samples_vec = t5.rvs_vec(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 608: `let samples_array = t5.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 613: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 622: `let t5 = StudentT::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 626: `assert_relative_eq!(t5.var(), 5.0 / 3.0, epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 627: `assert_relative_eq!(t5.std(), (5.0 / 3.0f64).sqrt(), epsilon = 1e-10);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 627: `assert_relative_eq!(t5.std(), (5.0 / 3.0f64).sqrt(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 630: `let t1 = StudentT::new(1.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 643: `let t5 = StudentT::new(5.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 655: `assert_relative_eq!(dist.ppf(0.5).unwrap(), 0.0, epsilon = 1e-10);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 664: `dist.isf(0.95).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 665: `dist.ppf(0.05).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()

### src/distributions/t.rs

70 issues found:

- Line 55: `let df_f64 = <f64 as NumCast>::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 91: `let z = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 94: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 96: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 99: `let df_half = self.df / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 100: `let df_plus_half = (self.df + one) / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 106: `let gamma_ratio = gamma_function(df_plus_half) / gamma_function(df_half);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 107: `let denominator = (self.df * pi).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 108: `let term = one + (z * z) / self.df;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 109: `let exponent = -(self.df + one) / two;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 112: `let std_pdf = gamma_ratio / denominator * term.powf(exponent);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 112: `let std_pdf = gamma_ratio / denominator * term.powf(exponent);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 115: `std_pdf / self.scale`
  - **Fix**: Division without zero check - use safe_divide()
- Line 139: `let z = (x - self.loc) / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 143: `return F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 147: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 154: `self.df / (self.df + z * z),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 161: `self.df / (self.df + z * z),`
  - **Fix**: Division without zero check - use safe_divide()
- Line 199: `if p == F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 205: `let mut lower = F::from(-100.0).unwrap(); // Reasonable lower bound`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 206: `let mut upper = F::from(100.0).unwrap();  // Reasonable upper bound`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 207: `let tolerance = F::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 211: `let mid = (lower + upper) / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 228: `Ok(self.loc + self.scale * (lower + upper) / F::from(2.0).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 257: `samples.push(F::from(sample).unwrap() * self.scale + self.loc);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 280: `if x == F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 281: `return F::from(std::f64::consts::PI).unwrap().sqrt(); // Gamma(0.5) = sqrt(Ï€)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 285: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 287: `let n = (x - F::from(0.5).unwrap()).to_f64().unwrap() as i32;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 289: `let sqrt_pi = F::from(std::f64::consts::PI).unwrap().sqrt();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 294: `factorial = factorial * F::from(i as f64 + 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 302: `let e = F::from(std::f64::consts::E).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 303: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 306: `let term1 = (two * pi / x).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 306: `let term1 = (two * pi / x).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 307: `let term2 = (x / e).powf(x);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 307: `let term2 = (x / e).powf(x);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 325: `let epsilon = F::from(1e-10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 328: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 338: `let mut bz = one - qab * x / qap;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 342: `let m_f = F::from(m as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 343: `let two_m = F::from(2 * m as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 347: `let d = m_f * (b - m_f) * x / ((qam + two_m) * (a + two_m));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 352: `let d = -(a + m_f) * (qab + m_f) * x / ((a + two_m) * (qap + two_m));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 364: `let azbz = az / bz;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 365: `if (azbz - h).abs() / azbz < epsilon {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 373: `let beta_term = gamma_function(a) * gamma_function(b) / gamma_function(a + b);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 374: `let x_pow_a = x.powf(a);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 375: `let one_minus_x_pow_b = (one - x).powf(b);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 377: `x_pow_a * one_minus_x_pow_b * h / (a * beta_term)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 388: `let t = StudentT::new(10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 394: `let custom = StudentT::new(5.0, 2.0, 3.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `let t = StudentT::new(10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 424: `let t_loc_scale = StudentT::new(10.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 428: `assert_relative_eq!(pdf_at_one_loc_scale, 0.3940886 / 2.0, epsilon = 1e-5);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 434: `let t = StudentT::new(10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `let t_loc_scale = StudentT::new(10.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 458: `let t = StudentT::new(10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 461: `let median = t.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 465: `let p975 = t.ppf(0.975).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 469: `let p025 = t.ppf(0.025).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `let t_loc_scale = StudentT::new(10.0, 1.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 478: `let median_loc_scale = t_loc_scale.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 484: `let t = StudentT::new(10.0, 0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 487: `let samples = t.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 494: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 500: `let t_loc_scale = StudentT::new(10.0, 5.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 501: `let samples_loc_scale = t_loc_scale.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 503: `let mean_loc_scale = sum_loc_scale / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 518: `let sqrt_pi = std::f64::consts::PI.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation

### src/distributions/uniform.rs

24 issues found:

- Line 49: `let low_f64 = <f64 as NumCast>::from(low).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 50: `let high_f64 = <f64 as NumCast>::from(high).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 86: `F::one() / (self.high - self.low)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 117: `(x - self.low) / (self.high - self.low)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 176: `samples.push(F::from(sample).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 186: `(self.low + self.high) / F::from(2.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 191: `range * range / F::from(12.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 195: `self.var().sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 203: `(self.high - self.low).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 238: `let unif = Uniform::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 243: `let custom = Uniform::new(-1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 255: `let unif = Uniform::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 274: `let unif2 = Uniform::new(0.0, 2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 282: `let unif = Uniform::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 304: `let unif2 = Uniform::new(-1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 312: `let unif = Uniform::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 315: `let median = unif.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 319: `let p75 = unif.ppf(0.75).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 323: `let p25 = unif.ppf(0.25).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 331: `let unif2 = Uniform::new(-1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 332: `let median2 = unif2.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 338: `let unif = Uniform::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 341: `let samples = unif.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 348: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()

### src/distributions/weibull.rs

58 issues found:

- Line 107: `let x_scaled = x_shifted / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 109: `let x_pow = x_scaled.powf(shape_minus_one);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 112: `let x_pow_shape = x_scaled.powf(self.shape);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 116: `(self.shape / self.scale) * x_pow * exp_term`
  - **Fix**: Division without zero check - use safe_divide()
- Line 148: `let x_scaled = x_shifted / self.scale;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 149: `let x_pow_shape = x_scaled.powf(self.shape);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 190: `let ln_term = (one - p).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 191: `let quantile = self.scale * ((-ln_term).powf(one / self.shape)) + self.loc;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 191: `let quantile = self.scale * ((-ln_term).powf(one / self.shape)) + self.loc;`
  - **Fix**: Mathematical operation .powf( without validation
- Line 223: `let u_f = F::from(u).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 251: `let gamma_arg = one + one / self.shape;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 272: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 275: `let gamma_arg_2 = one + two / self.shape;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 279: `let gamma_arg_1 = one + one / self.shape;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 303: `let ln2 = F::from(std::f64::consts::LN_2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 305: `self.scale * ln2.powf(one / self.shape) + self.loc`
  - **Fix**: Division without zero check - use safe_divide()
- Line 305: `self.scale * ln2.powf(one / self.shape) + self.loc`
  - **Fix**: Mathematical operation .powf( without validation
- Line 333: `let mode_term = (shape_minus_one / self.shape).powf(one / self.shape);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 333: `let mode_term = (shape_minus_one / self.shape).powf(one / self.shape);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 353: `F::from(676.520_368_121_885_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 354: `F::from(-1_259.139_216_722_402_8).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 355: `F::from(771.323_428_777_653_1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 356: `F::from(-176.615_029_162_140_6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 357: `F::from(12.507_343_278_686_905).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 358: `F::from(-0.138_571_095_265_720_12).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 359: `F::from(9.984_369_578_019_572e-6).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 360: `F::from(1.505_632_735_149_311_6e-7).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 363: `if x < F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 365: `let pi = F::from(std::f64::consts::PI).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 367: `pi / (sin_pi_x * gamma_function(F::one() - x))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 370: `let half = F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 372: `let y = z + F::from(7.5).unwrap(); // g+0.5, where g=7`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 377: `sum = sum + coef / (z + F::from(i as f64 + 1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 381: `let sqrt_2pi = F::from(2.506_628_274_631_001).unwrap(); // sqrt(2*pi)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 382: `sqrt_2pi * sum * y.powf(z + half) * (-y).exp()`
  - **Fix**: Mathematical operation .powf( without validation
- Line 432: `let weibull1 = Weibull::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 438: `let weibull2 = Weibull::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 444: `let custom = Weibull::new(3.5, 2.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 459: `let weibull1 = Weibull::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 470: `let weibull2 = Weibull::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `let custom = Weibull::new(2.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 490: `let weibull1 = Weibull::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 501: `let weibull2 = Weibull::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 508: `let custom = Weibull::new(2.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 521: `let weibull1 = Weibull::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 524: `let ppf_at_half = weibull1.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 528: `let weibull2 = Weibull::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 531: `let ppf_at_half2 = weibull2.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 535: `let custom = Weibull::new(2.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 538: `let ppf_at_half_shifted = custom.ppf(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 549: `let weibull1 = Weibull::new(1.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 568: `let weibull2 = Weibull::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 587: `let custom = Weibull::new(2.0, 1.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 600: `let weibull = Weibull::new(2.0, 1.0, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 603: `let samples = weibull.rvs(1000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 615: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 622: `sorted_samples.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 624: `(sorted_samples[499] + sorted_samples[500]) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()

### src/error_suggestions.rs

8 issues found:

- Line 79: `.sum::<f64>() / valid_count as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 183: `let mean = data.mean().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 185: `let standardized = (data - mean) / std;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 249: `let min = data.min().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 250: `let max = data.max().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 251: `let scaled = (data - min) / (max - min);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 254: `let log_transformed = data.mapv(|x| x.ln());`
  - **Fix**: Mathematical operation .ln() without validation
- Line 271: `max_val + sum.ln()`
  - **Fix**: Mathematical operation .ln() without validation

### src/mcmc/metropolis.rs

5 issues found:

- Line 49: `let normal = Normal::new(0.0, self.step_size).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 104: `let u: f64 = Uniform::new(0.0, 1.0).unwrap().sample(rng);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `if u.ln() < log_ratio {`
  - **Fix**: Mathematical operation .ln() without validation
- Line 155: `self.n_accepted as f64 / self.n_proposed as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 276: `let log_norm_const = -0.5 * (d * (2.0 * std::f64::consts::PI).ln() + det_value.l...`
  - **Fix**: Mathematical operation .ln() without validation

### src/memory_efficient.rs

40 issues found:

- Line 55: `Ok(sum / F::from(total_count).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 90: `mean = mean + delta / F::from(count).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 95: `let variance = m2 / F::from(n - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 120: `let std_dev = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 124: `*val = (*val - mean) / std_dev;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 156: `let pos = q * F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 157: `let k = NumCast::from(pos.floor()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 198: `let pivot_idx = left + (right - left) / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 249: `means[j] = col.iter().fold(F::zero(), |acc, &val| acc + val) / F::from(n_obs).un...`
  - **Fix**: Use .get() with proper bounds checking
- Line 256: `let chunk_size = CHUNK_SIZE / n_vars;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 276: `let factor = F::from(n_obs - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 279: `cov_matrix[(i, j)] = cov_matrix[(i, j)] / factor;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 342: `let n = F::from(self.n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 343: `let mean_x = self.sum_x / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 344: `let mean_y = self.sum_y / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 346: `let cov_xy = (self.sum_xy - n * mean_x * mean_y) / (n - F::one());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 347: `let var_x = (self.sum_xx - n * mean_x * mean_x) / (n - F::one());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 348: `let var_y = (self.sum_yy - n * mean_y * mean_y) / (n - F::one());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 356: `Ok(cov_xy / (var_x * var_y).sqrt())`
  - **Fix**: Division without zero check - use safe_divide()
- Line 356: `Ok(cov_xy / (var_x * var_y).sqrt())`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 400: `let n = F::from(self.n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 407: `self.means[i] = self.means[i] + delta[i] / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 414: `let cov_update = delta[i] * delta_new * (n - F::one()) / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 434: `let factor = F::from(self.n - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 435: `Ok(&self.cov_matrix / factor)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 505: `self.sum / F::from(n).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 519: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 520: `let variance = (self.sum_squares / n_f) - mean * mean;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 521: `Ok(variance * n_f / F::from(n - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `let bin_width = (max_val - min_val) / F::from(n_bins).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 550: `.map(|i| min_val + F::from(i).unwrap() * bin_width)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 566: `let bin_width = (self.max_val - self.min_val) / F::from(n_bins).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 567: `let bin_idx = ((value - self.min_val) / bin_width).floor();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 592: `let bin_width = (self.max_val - self.min_val) / F::from(n_bins).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 593: `let total = F::from(self.total_count).unwrap() * bin_width;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 597: `.map(|&count| F::from(count).unwrap() / total)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 671: `Ok(sum / F::from(count).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 730: `let variance = sum_sq / F::from(count - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 757: `let n_elements = bytes_read / element_size;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 817: `mmap.len() / std::mem::size_of::<F>()`
  - **Fix**: Division without zero check - use safe_divide()

### src/memory_optimized_v2.rs

17 issues found:

- Line 113: `Ok(sum / F::from(x.len()).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 136: `let cache_elements = config.cache_line_size / std::mem::size_of::<F>();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 158: `Ok(sum_sq_dev / F::from(n - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 236: `self.quantile(F::from(0.5).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 252: `let sorted = sorted_ref.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 254: `let pos = q * F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 293: `let n_f = F::from(self.n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 300: `self.means[i] = self.means[i] + deltas[i] / n_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 325: `let factor = F::from(self.n - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 330: `result[i][j] = result[i][j] / factor;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 361: `let n_elements = file_size / element_size;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 392: `Ok(sum / self.n_elements as f64)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 419: `assert!((stats.mean().unwrap() - 3.0).abs() < 1e-10);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 420: `assert!((stats.variance(1).unwrap() - 2.5).abs() < 1e-10);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 422: `let (min, max) = stats.minmax().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 426: `assert!((stats.median().unwrap() - 3.0).abs() < 1e-10);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 439: `let result = cov.covariance(1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/memory_profiling.rs

20 issues found:

- Line 82: `AlgorithmChoice::Streaming(self.preferred_chunk_size / element_size)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 185: `Ok(total_sum / F::from(total_count).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 206: `mean = mean + delta / F::from(count).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 212: `let variance = m2 / F::from(count - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 255: `self.sum / F::from(self.buffer.len()).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 267: `let var = self.sum_squares / F::from(n).unwrap() - mean * mean;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 268: `Some(var * F::from(n).unwrap() / F::from(n - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 273: `self.variance(ddof).map(|v| v.sqrt())`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 329: `Some(data.iter().sum::<F>() / F::from(data.len()).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 336: `sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 346: `results.push(mean.unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 349: `let m = mean.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 355: `.sum::<F>() / F::from(data.len() - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 359: `let sorted = sorted_data.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 369: `lower + F::from(frac).unwrap() * (upper - lower)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 420: `1.0 - (self.current_usage as f64 / self.peak_usage as f64)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 427: `avg_memory: (self.peak_usage + self.current_usage) / 2,`
  - **Fix**: Division without zero check - use safe_divide()
- Line 531: `let results = lazy.compute().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 542: `Ok(window.mean().unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 543: `}).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/multivariate/pca.rs

27 issues found:

- Line 133: `data.mean_axis(Axis(0)).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 162: `if n_samples >= 500 && n_features >= 500 && n_components < max_components / 2 {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 202: `let v = vt.unwrap().t().to_owned();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 209: `let explained_variance = &singular_values * &singular_values / (n_samples - 1) a...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 213: `let explained_variance_ratio = &explained_variance / total_variance;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 230: `let n_oversamples = 10.min((n_features - n_components) / 2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 273: `let v = vt.unwrap().t().to_owned();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 280: `let explained_variance = &singular_values * &singular_values / (n_samples - 1) a...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 284: `let explained_variance_ratio = &explained_variance / total_variance;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 377: `eigenvalues.slice(ndarray::s![k+1..]).sum() / (p - k_f64 - 1.0)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 383: `let ll = -n / 2.0 * (eigenvalues.slice(ndarray::s![..=k]).mapv(f64::ln).sum()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 384: `+ (p - k_f64 - 1.0) * sigma2.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 385: `+ p * (2.0 * std::f64::consts::PI).ln());`
  - **Fix**: Mathematical operation .ln() without validation
- Line 446: `let batch_mean = batch.mean_axis(Axis(0)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `/ self.n_samples_seen as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 474: `let u = u.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 475: `let vt = vt.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 482: `self.components = Some(self.svd_v.as_ref().unwrap().t().to_owned());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 483: `self.singular_values = Some(self.svd_s.as_ref().unwrap().clone());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 486: `let u_old = self.svd_u.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 487: `let s_old = self.svd_s.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 488: `let v_old = self.svd_v.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 524: `let u_aug = u_aug.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 525: `let vt_aug = vt_aug.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 554: `self.singular_values = Some(self.svd_s.as_ref().unwrap().clone());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 570: `row -= self.mean.as_ref().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 573: `Ok(centered.dot(&self.components.as_ref().unwrap().t()))`
  - **Fix**: Replace with ? operator or .ok_or()

### src/parallel_enhanced_v2.rs

15 issues found:

- Line 97: `return Ok(sum / F::from(n).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 109: `Ok(sum / F::from(n).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 140: `let n_chunks = (n + chunk_size - 1) / chunk_size;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 159: `local_mean = local_mean + delta / F::from(count).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 171: `Ok(total_m2 / F::from(n - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 307: `let n_chunks = (n + chunk_size - 1) / chunk_size;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 340: `mean = mean + delta / F::from(count).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `Ok(m2 / F::from(count - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 358: `let mean = mean_a + delta * F::from(count_b).unwrap() / F::from(count).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 360: `delta * delta * F::from(count_a).unwrap() * F::from(count_b).unwrap() /`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 361: `F::from(count).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 391: `cov / (var_x * var_y).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 391: `cov / (var_x * var_y).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 417: `let mean = mean_parallel_enhanced(&data.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 424: `let var = variance_parallel_enhanced(&data.view(), 1, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/parallel_stats.rs

11 issues found:

- Line 44: `let chunk_size = (n / num_threads()).max(1000);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 45: `let sum: F = par_chunks(x.as_slice().unwrap(), chunk_size)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 49: `Ok(sum / F::from(n).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 82: `let chunk_size = (n / num_threads()).max(1000);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 83: `let sum_sq_dev: F = par_chunks(x.as_slice().unwrap(), chunk_size)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 94: `Ok(sum_sq_dev / F::from(n - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 144: `sorted.as_slice_mut().unwrap().sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 149: `let pos = q * F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 153: `let idx_usize: usize = NumCast::from(idx).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 190: `if nrows < PARALLEL_THRESHOLD / data.ncols() {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 294: `if n_samples < PARALLEL_THRESHOLD / data.len() {`
  - **Fix**: Division without zero check - use safe_divide()

### src/parallel_stats_enhanced.rs

53 issues found:

- Line 50: `let core_factor = (self.cpu_cores as f64).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 51: `let cache_factor = (self.cache_line_size / element_size).max(1) as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 55: `/ core_factor`
  - **Fix**: Division without zero check - use safe_divide()
- Line 56: `/ operation_complexity`
  - **Fix**: Division without zero check - use safe_divide()
- Line 57: `* cache_factor.sqrt()) as usize;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 66: `let elements_per_cache = l1_cache_size / element_size;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 73: `let max_chunk_size = total_elements / min_chunks;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 105: `let (min, max) = par_chunks(data.as_slice().unwrap(), chunk_size)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 136: `let bin_width = range / F::from(n_bins).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 139: `.map(|i| min_val + bin_width * F::from(i).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 166: `let bin_width = (self.max_val - self.min_val) / F::from(self.n_bins).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 170: `let bin_idx = ((val - self.min_val) / bin_width)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 173: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 181: `let bin_width = (self.max_val - self.min_val) / F::from(self.n_bins).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 186: `let local_histograms: Vec<Vec<usize>> = par_chunks(data.as_slice().unwrap(), chu...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 192: `let bin_idx = ((val - min_val) / bin_width)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 195: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 243: `let norm_const = F::one() / (F::from(2.0 * PI).unwrap().sqrt() * bandwidth * F::...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 252: `let u = (x - xi) / bandwidth;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 253: `density = density + (-u * u / F::from(2.0).unwrap()).exp();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 262: `let data_slice = data.as_slice().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 272: `let u = (x - xi) / bandwidth;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 273: `local_sum = local_sum + (-u * u / F::from(2.0).unwrap()).exp();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 319: `let window_size_f = F::from(self.window_size).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 325: `result[0] = window_sum / window_size_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 330: `result[i] = window_sum / window_size_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 339: `let window_size_f = F::from(window_size).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `window_sum / window_size_f`
  - **Fix**: Division without zero check - use safe_divide()
- Line 367: `let divisor = F::from(self.window_size - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 372: `/ F::from(self.window_size).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 379: `.fold(F::zero(), |acc, x| acc + x) / divisor;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 381: `result[i] = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 390: `let divisor = F::from(window_size - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 395: `/ F::from(window_size).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 402: `.fold(F::zero(), |acc, x| acc + x) / divisor;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 404: `variance.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 440: `sum.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 474: `F::simd_sum(&squared.view()).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 481: `sum.sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 546: `permutation_int(n_samples, self.random_state).unwrap().to_vec()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 552: `let fold_size = n_samples / self.n_folds;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 845: `sum / (F::from(n - lag).unwrap() * variance)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 867: `sum / (F::from(n - lag).unwrap() * variance)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 874: `sum / (F::from(n - lag).unwrap() * variance)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 891: `let data = Array1::from_vec((0..10000).map(|i| i as f64 / 100.0).collect());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 892: `let hist = ParallelHistogram::new(&data.view(), 10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 904: `let kde_result = kde_parallel(&data.view(), &eval_points, 0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 910: `.max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 912: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 920: `let moving_stats = ParallelMovingStats::new(&data.view(), 10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 922: `let moving_mean = moving_stats.moving_mean().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 941: `let distances = pairwise_distances_parallel(&data.view(), "euclidean").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 950: `assert_relative_eq!(distances[(0, 3)], 2.0_f64.sqrt(), epsilon = 1e-10);`
  - **Fix**: Mathematical operation .sqrt() without validation

### src/quantile.rs

67 issues found:

- Line 125: `let n = F::from(sorted_data.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 129: `let index = (q * (n - F::one())).floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 136: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 144: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 149: `let i_lower = (q * (n - F::one())).floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 153: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 155: `Ok((sorted_data[i_lower] + sorted_data[i_upper]) / F::from(2.0).unwrap())`
  - **Fix**: Use .get() with proper bounds checking
- Line 159: `let j = jg.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 177: `let j = jg.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 179: `F::from(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 194: `let jg = q * n - F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 195: `let j = jg.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 218: `QuantileInterpolation::Hazen => F::from(0.5).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 222: `q / F::from(3.0).unwrap() + F::from(1.0 / 3.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 225: `q / F::from(4.0).unwrap() + F::from(3.0 / 8.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 231: `let j = jg.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 298: `if p < F::zero() || p > F::from(100.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 305: `let q = p / F::from(100.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 351: `let q1 = quantile(x, F::from(0.25).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 352: `let q2 = quantile(x, F::from(0.5).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 353: `let q3 = quantile(x, F::from(0.75).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 400: `let q1 = quantile(x, F::from(0.2).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 401: `let q2 = quantile(x, F::from(0.4).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 402: `let q3 = quantile(x, F::from(0.6).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 403: `let q4 = quantile(x, F::from(0.8).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 451: `let p = F::from(i * 10).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 517: `let whis_factor = whis.unwrap_or(F::from(1.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 525: `let q1 = quantile(x, F::from(0.25).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 526: `let q2 = quantile(x, F::from(0.5).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 527: `let q3 = quantile(x, F::from(0.75).unwrap(), method)?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 609: `if limits < F::zero() || limits > F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `return Ok(x.iter().cloned().sum::<F>() / F::from(x.len()).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 628: `let n_replace = (F::from(n).unwrap() * limits).to_usize().unwrap().max(1);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 641: `let mean = data.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 687: `if limits < F::zero() || limits > F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 708: `let n_replace = (F::from(n).unwrap() * limits).to_usize().unwrap().max(1);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 721: `let mean = data.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 725: `let denom = F::from(n - ddof).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 727: `Ok(sum_sq_dev / denom)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 741: `let median = quantile(&data.view(), 0.5, QuantileInterpolation::Linear).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 744: `let q1 = quantile(&data.view(), 0.25, QuantileInterpolation::Linear).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 747: `let q3 = quantile(&data.view(), 0.75, QuantileInterpolation::Linear).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 751: `let q_lower = quantile(&data.view(), 0.4, QuantileInterpolation::Lower).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 754: `let q_higher = quantile(&data.view(), 0.4, QuantileInterpolation::Higher).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 757: `let q_midpoint = quantile(&data.view(), 0.4, QuantileInterpolation::Midpoint).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 766: `let q_type1 = quantile(&data.view(), 0.4, QuantileInterpolation::InvertedCdf).un...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 774: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 778: `quantile(&data.view(), 0.4, QuantileInterpolation::ClosestObservation).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 786: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 789: `let q_type5 = quantile(&data.view(), 0.4, QuantileInterpolation::Hazen).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 792: `let q_type6 = quantile(&data.view(), 0.4, QuantileInterpolation::Weibull).unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 795: `let q_type7 = quantile(&data.view(), 0.4, QuantileInterpolation::Linear).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 798: `let q_type8 = quantile(&data.view(), 0.4, QuantileInterpolation::MedianUnbiased)...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 801: `let q_type9 = quantile(&data.view(), 0.4, QuantileInterpolation::NormalUnbiased)...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 810: `let p50 = percentile(&data.view(), 50.0, QuantileInterpolation::Linear).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 813: `let p25 = percentile(&data.view(), 25.0, QuantileInterpolation::Linear).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 816: `let p75 = percentile(&data.view(), 75.0, QuantileInterpolation::Linear).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 829: `let q = quartiles(&data.view(), QuantileInterpolation::Linear).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 840: `let q = quintiles(&data.view(), QuantileInterpolation::Linear).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 852: `let d = deciles(&data.view(), QuantileInterpolation::Linear).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 864: `boxplot_stats(&data.view(), Some(1.5), QuantileInterpolation::Linear).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 887: `let mean_10 = winsorized_mean(&data.view(), 0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 894: `let mean_20 = winsorized_mean(&data.view(), 0.2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 901: `let mean_0 = winsorized_mean(&data.view(), 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 902: `let expected_mean = data.iter().sum::<f64>() / data.len() as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 911: `let var_10 = winsorized_variance(&data.view(), 0.1, 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 921: `let var_20 = winsorized_variance(&data.view(), 0.2, 0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/quantile_simd.rs

23 issues found:

- Line 47: `let mid = left + (right - left) / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 176: `return Ok(*x.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 179: `return Ok(*x.iter().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `let data = x.as_slice_mut().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 186: `let pos = q * F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 187: `let lower_idx = pos.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 188: `let upper_idx = pos.ceil().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 202: `"midpoint" => Ok((lower_val + upper_val) / F::from(2.0).unwrap()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 204: `if fraction < F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 255: `let data = x.as_slice_mut().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 354: `for i in (0..n / 2).rev() {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 402: `let pos = q * F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 403: `let lower_idx = pos.floor().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 404: `let upper_idx = pos.ceil().to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 417: `"midpoint" => Ok((lower_val + upper_val) / F::from(2.0).unwrap()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 419: `if fraction < F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 438: `quantile_simd(x, F::from(0.5).unwrap(), "linear")`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 453: `if p < F::zero() || p > F::from(100.0).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 457: `quantile_simd(x, p / F::from(100.0).unwrap(), method)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 478: `let median = quantile_simd(&mut data.view_mut(), 0.5, "linear").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 482: `let q1 = quantile_simd(&mut data.view_mut(), 0.25, "linear").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 485: `let q3 = quantile_simd(&mut data.view_mut(), 0.75, "linear").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 494: `let results = quantiles_simd(&mut data.view_mut(), &quantiles.view(), "linear")....`
  - **Fix**: Replace with ? operator or .ok_or()

### src/random.rs

18 issues found:

- Line 331: `let mid = (low + high) / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 390: `let uniform = rand_distr::Uniform::new(0, n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 659: `let uniform = rand_distr::Uniform::new(0, n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 682: `let uniform_dist = rand_distr::Uniform::new(0.0, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 683: `let samples = random_sample(100, &uniform_dist, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 697: `let samples = uniform(10.0, 20.0, 50, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 713: `let samples = randint(1, 101, 100, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 729: `let samples = randn(1000, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 735: `let mean = sum / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 739: `let variance = sum_sq / 1000.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 756: `let choices = choice(&options.view(), 10, true, None, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 765: `let choices_no_replace = choice(&options.view(), 3, false, None, Some(123)).unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 778: `choice(&options.view(), 5, true, Some(&weights.view()), Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 803: `let perm = permutation(&arr.view(), Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 821: `let perm = permutation_int(10, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 838: `let matrix = random_binary_matrix(5, 5, 0.5, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 850: `let density = ones_count as f64 / 25.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 867: `let samples = bootstrap_sample(&data.view(), 10, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/regression/linear.rs

30 issues found:

- Line 104: `F::from(std::cmp::max(x.nrows(), x.ncols())).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 117: `beta[0] = F::from(1.0).unwrap(); // intercept`
  - **Fix**: Use .get() with proper bounds checking
- Line 118: `beta[1] = F::from(2.0).unwrap(); // x1 coefficient`
  - **Fix**: Use .get() with proper bounds checking
- Line 119: `beta[2] = F::from(3.0).unwrap(); // x2 coefficient`
  - **Fix**: Use .get() with proper bounds checking
- Line 224: `let _conf_level = conf_level.unwrap_or_else(|| F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 233: `beta[0] = F::from(1.0).unwrap(); // intercept`
  - **Fix**: Use .get() with proper bounds checking
- Line 234: `beta[1] = F::from(2.0).unwrap(); // x1 coefficient`
  - **Fix**: Use .get() with proper bounds checking
- Line 235: `beta[2] = F::from(3.0).unwrap(); // x2 coefficient`
  - **Fix**: Use .get() with proper bounds checking
- Line 255: `let y_mean = y.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 271: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 274: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 286: `F::from(1e10).unwrap() // Large t-value for perfect fit`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 288: `coef / se`
  - **Fix**: Division without zero check - use safe_divide()
- Line 308: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 392: `let x_mean = x.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 393: `let y_mean = y.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 417: `let slope = ss_xy / ss_x;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 421: `let r = ss_xy / num_traits::Float::sqrt(ss_x * ss_y);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 424: `let df = F::from(n - 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 427: `let residual_ss = ss_y - ss_xy * ss_xy / ss_x;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 430: `let std_err = num_traits::Float::sqrt(residual_ss / df) / num_traits::Float::sqr...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 434: `let t_stat = r * num_traits::Float::sqrt(df) / num_traits::Float::sqrt(F::one() ...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 439: `let p_value = F::from(2.0).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 440: `* F::from(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 442: `- (num_traits::Float::powi(t_stat, 2) / (df + num_traits::Float::powi(t_stat, 2)...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 519: `let x_mean = x.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 520: `let y_mean = y.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 540: `+ F::from(4.0).unwrap() * num_traits::Float::powi(s_xy, 2);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 543: `(s_yy - s_xx + num_traits::Float::sqrt(discriminant)) / (F::from(2.0).unwrap() *...`
  - **Fix**: Replace with ? operator or .ok_or()

### src/regression/mod.rs

1 issues found:

- Line 216: `let outlier_percentage = (outlier_count as f64 * 100.0) / self.inlier_mask.len()...`
  - **Fix**: Division without zero check - use safe_divide()

### src/regression/polynomial.rs

4 issues found:

- Line 116: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 118: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 146: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()

### src/regression/regularized.rs

69 issues found:

- Line 93: `let alpha = alpha.unwrap_or_else(|| F::from(1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 96: `let tol = tol.unwrap_or_else(|| F::from(1e-4).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 98: `let conf_level = conf_level.unwrap_or_else(|| F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 179: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 181: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 184: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 204: `let df_f = F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 205: `let ratio = t_abs / crate::regression::utils::float_sqrt(df_f + t_abs * t_abs);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 207: `F::from(2.0).unwrap() * one_minus_ratio`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 212: `let z = norm_ppf(F::from(0.5).unwrap() * (F::one() + conf_level));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 222: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 289: `y.iter().cloned().sum::<F>() / F::from(n).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 301: `let mean = col.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 309: `let std_dev = num_traits::Float::sqrt(ss / F::from(n).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 338: `(x[[i, j]] - x_mean[j]) / x_std[j]`
  - **Fix**: Division without zero check - use safe_divide()
- Line 370: `intercept = intercept - coefficients[j + 1] * x_mean[j] / x_std[j];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 380: `transformed[j + 1] = coefficients[j + 1] / x_std[j];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 385: `transformed[j] = coefficients[j] / x_std[j];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 413: `/ F::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 530: `let alpha = alpha.unwrap_or_else(|| F::from(1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 533: `let tol = tol.unwrap_or_else(|| F::from(1e-4).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 535: `let conf_level = conf_level.unwrap_or_else(|| F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 599: `coefficients[j] = r_partial / xtx_jj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 605: `coefficients[j] = (r_partial - alpha) / xtx_jj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 607: `coefficients[j] = (r_partial + alpha) / xtx_jj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 621: `if coef_diff / coef_norm < tol {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 659: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 661: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 664: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 684: `let df_f = F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 685: `let ratio = t_abs / crate::regression::utils::float_sqrt(df_f + t_abs * t_abs);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 687: `F::from(2.0).unwrap() * one_minus_ratio`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 692: `let z = norm_ppf(F::from(0.5).unwrap() * (F::one() + conf_level));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 702: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 750: `/ F::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 885: `let alpha = alpha.unwrap_or_else(|| F::from(1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 886: `let l1_ratio = l1_ratio.unwrap_or_else(|| F::from(0.5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 889: `let tol = tol.unwrap_or_else(|| F::from(1e-4).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 891: `let conf_level = conf_level.unwrap_or_else(|| F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 994: `coefficients[j] = r_partial / xtx_jj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1000: `coefficients[j] = (r_partial - alpha_l1) / xtx_jj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1002: `coefficients[j] = (r_partial + alpha_l1) / xtx_jj;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1016: `if coef_diff / coef_norm < tol {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1054: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1056: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1059: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1080: `let df_f = F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1081: `let ratio = t_abs / crate::regression::utils::float_sqrt(df_f + t_abs * t_abs);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1083: `F::from(2.0).unwrap() * one_minus_ratio`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1088: `let z = norm_ppf(F::from(0.5).unwrap() * (F::one() + conf_level));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1098: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1147: `/ F::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1300: `let alpha = alpha.unwrap_or_else(|| F::from(1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1303: `let tol = tol.unwrap_or_else(|| F::from(1e-4).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1305: `let conf_level = conf_level.unwrap_or_else(|| F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1366: `coefficients[0] = r_sum / F::from(r.len()).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 1432: `let shrinkage = F::one().max((beta_norm - alpha) / beta_norm);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1453: `if coef_diff / coef_norm < tol {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1508: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1510: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1513: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1535: `let df_f = F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1536: `let ratio = t_abs / crate::regression::utils::float_sqrt(df_f + t_abs * t_abs);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1538: `F::from(2.0).unwrap() * one_minus_ratio`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1543: `let z = norm_ppf(F::from(0.5).unwrap() * (F::one() + conf_level));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1553: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1618: `let lr = F::from(0.01).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1640: `if beta_diff / beta_norm < tol {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1673: `/ F::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/regression/robust.rs

42 issues found:

- Line 86: `t: F::from(1.345).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 122: `F::from(0.5).unwrap() * crate::regression::utils::float_powi(r, 2)`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 124: `self.t * abs_r - F::from(0.5).unwrap() * crate::regression::utils::float_powi(se...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 160: `t / abs_r`
  - **Fix**: Division without zero check - use safe_divide()
- Line 230: `let alpha = alpha.unwrap_or_else(|| F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 269: `let y_avg = y_sum / F::from(repeats.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 291: `let z = norm_ppf(F::from(0.5).unwrap() * (F::one() + alpha));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 292: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 299: `F::from(1.0).unwrap() / (F::from(6.0).unwrap() * num_traits::Float::sqrt(n_f))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 304: `F::from(3.0).unwrap() * n_f * (n_f + F::one())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 305: `/ (F::from(0.5).unwrap() * n_f * (n_f - F::one())),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 307: `factor / (num_traits::Float::sqrt(n_f) * num_traits::Float::sqrt(n_f - F::one())...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 339: `.unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 342: `let mid = n / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 344: `(sorted[mid - 1] + sorted[mid]) / F::from(2.0).unwrap()`
  - **Fix**: Use .get() with proper bounds checking
- Line 482: `let stop_probability = stop_probability.unwrap_or_else(|| F::from(0.99).unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 513: `mad * F::from(2.5).unwrap() // Typically 2.0-3.0 times MAD`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 607: `let inlier_ratio = F::from(inlier_count).unwrap() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 617: `let new_n_trials = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 739: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 741: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 744: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 759: `let df_f = F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 760: `F::from(2.0).unwrap() * (F::one() - t_abs / num_traits::Float::sqrt(df_f + t_abs...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 766: `let margin = std_errors[i] * F::from(1.96).unwrap(); // Approximate 95% CI`
  - **Fix**: Use .get() with proper bounds checking
- Line 773: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 943: `let epsilon = epsilon.unwrap_or_else(|| F::from(1.345).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 946: `let tol = tol.unwrap_or_else(|| F::from(1e-5).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 947: `let conf_level = conf_level.unwrap_or_else(|| F::from(0.95).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 978: `mad / F::from(0.6745).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 994: `let weight = (huber.weight_func)(residuals[i] / sigma, huber.t);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1000: `if weight_sum / F::from(n).unwrap() > F::one() - tol {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1022: `/ F::from(n).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1029: `/ coefficients`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1050: `let y_mean = y.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1064: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 1066: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1069: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1090: `let df_f = F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1091: `F::from(2.0).unwrap() * (F::one() - t_abs / num_traits::Float::sqrt(df_f + t_abs...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1096: `let z = norm_ppf(F::from(0.5).unwrap() * (F::one() + conf_level));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 1106: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()

### src/regression/stepwise.rs

15 issues found:

- Line 196: `let p_enter = p_enter.unwrap_or_else(|| F::from(0.05).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 197: `let p_remove = p_remove.unwrap_or_else(|| F::from(0.1).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 443: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 444: `let k_f = F::from(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 445: `n_f * num_traits::Float::ln(rss / n_f) + F::from(2.0).unwrap() * k_f`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 453: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 454: `let k_f = F::from(p).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 455: `n_f * num_traits::Float::ln(rss / n_f) + k_f * num_traits::Float::ln(n_f)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 538: `let r_squared = ss_explained / ss_total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 540: `- (F::one() - r_squared) * F::from(n - 1).unwrap() / F::from(df_residuals).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 543: `let mse = ss_residual / F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 559: `let df_f = F::from(df_residuals).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 560: `F::from(2.0).unwrap() * (F::one() - t_abs / num_traits::Float::sqrt(df_f + t_abs...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 566: `let margin = std_errors[i] * F::from(1.96).unwrap(); // Approximate 95% CI`
  - **Fix**: Use .get() with proper bounds checking
- Line 573: `(ss_explained / F::from(df_model).unwrap()) / (ss_residual / F::from(df_residual...`
  - **Fix**: Replace with ? operator or .ok_or()

### src/regression/utils.rs

22 issues found:

- Line 84: `/ F::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 115: `F::from(1e10).unwrap() // Large t-value for small standard error`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 117: `coef / se`
  - **Fix**: Division without zero check - use safe_divide()
- Line 166: `let mut slopes = Vec::with_capacity(n * (n - 1) / 2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 174: `slopes.push(dy / dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 183: `let mid = slopes.len() / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 185: `(slopes[mid - 1] + slopes[mid]) / F::from(2.0).unwrap()`
  - **Fix**: Use .get() with proper bounds checking
- Line 203: `.min(F::from(0.9999).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 204: `.max(F::from(0.0001).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 208: `F::from(2.515517).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 209: `F::from(0.802853).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 210: `F::from(0.010328).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 214: `F::from(1.432788).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 215: `F::from(0.189269).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 216: `F::from(0.001308).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 220: `let p_adj = if p <= F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 225: `let t = num_traits::Float::sqrt(-F::from(2.0).unwrap() * num_traits::Float::ln(p...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 230: `/ (F::one()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 236: `if p <= F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 260: `let mid = n / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 262: `(sorted_abs_x[mid - 1] + sorted_abs_x[mid]) / F::from(2.0).unwrap()`
  - **Fix**: Use .get() with proper bounds checking
- Line 310: `let y_mean = y.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/simd_optimized_v2.rs

23 issues found:

- Line 59: `return Ok(sum / F::from(n).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 64: `Ok(sum / F::from(n).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `Ok(sum_sq_dev / F::from(n - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 119: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 139: `let chunks = x.len() / simd_width;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 167: `let mean = m1 / n_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 200: `let variance = m2 / F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 201: `let std_dev = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 204: `(m3 / n_f) / (std_dev * std_dev * std_dev)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 210: `(m4 / n_f) / (variance * variance) - F::from(3).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 240: `let processed = (x.len() / CHUNK_SIZE) * CHUNK_SIZE;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 275: `let processed = (x.len() / CHUNK_SIZE) * CHUNK_SIZE;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 302: `mean = mean + delta / F::from(count).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 307: `Ok(m2 / F::from(count - ddof).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 319: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 322: `let mean = x.iter().fold(F::zero(), |acc, &val| acc + val) / n_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 345: `let variance = m2 / F::from(n - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 346: `let std_dev = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 349: `(m3 / n_f) / (std_dev * std_dev * std_dev)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 355: `(m4 / n_f) / (variance * variance) - F::from(3).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 371: `let mean = mean_simd_optimized(&data.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 378: `let var = variance_simd_optimized(&data.view(), 1, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 385: `let (mean, var, min, max, _, _) = stats_simd_single_pass(&data.view(), None).unw...`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/anova.rs

28 issues found:

- Line 125: `let size_f = F::from(group_size).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 142: `let ms_treatment = ss_treatment / F::from(df_treatment).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 143: `let ms_error = ss_error / F::from(df_error).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 146: `let f_statistic = ms_treatment / ms_error;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 150: `F::from(df_treatment).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 151: `F::from(df_error).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 234: `group_sizes.push(F::from(group.len()).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 241: `F::from(groups.len()).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 242: `F::from(anova_result.df_error).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 254: `let harmonic_mean_n = (F::from(2.0).unwrap() * group_sizes[i] * group_sizes[j])`
  - **Fix**: Use .get() with proper bounds checking
- Line 255: `/ (group_sizes[i] + group_sizes[j]);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 256: `let std_error = (anova_result.ms_error / harmonic_mean_n).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 256: `let std_error = (anova_result.ms_error / harmonic_mean_n).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 259: `let q_stat = mean_diff / std_error;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 265: `F::from(groups.len()).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 266: `F::from(anova_result.df_error).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 315: `let alpha_f64 = <f64 as NumCast>::from(alpha).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 316: `let k_f64 = <f64 as NumCast>::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 317: `let df_f64 = <f64 as NumCast>::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 368: `Ok(F::from(table[df_index][k_index]).unwrap())`
  - **Fix**: Use .get() with proper bounds checking
- Line 380: `let q_f64 = <f64 as NumCast>::from(q).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 381: `let k_f64 = <f64 as NumCast>::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 382: `let df_f64 = <f64 as NumCast>::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 388: `let z = q_f64 / adjustment;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 394: `let t = 1.0 / (1.0 + 0.2316419 * z);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 402: `let p_adjusted = 1.0 - (1.0 - p).powf(k_f64 - 1.0);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 405: `let df_adjustment = 1.0 - 10.0 / df_f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 409: `F::from(final_p.clamp(0.0, 1.0)).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/chi2_test.rs

13 issues found:

- Line 86: `obs_float[i] = F::from(val).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 103: `let uniform_exp = total_obs / F::from(observed.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 120: `chi2_stat = chi2_stat + (*obs - *exp).powi(2) / *exp;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 127: `let chi2_dist = chi2(F::from(df).unwrap(), F::zero(), F::one())?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 208: `obs_float[(i, j)] = F::from(observed[(i, j)]).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 221: `expected[(i, j)] = row_sums[i] * col_sums[j] / total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 240: `chi2_stat = chi2_stat + (obs - exp).powi(2) / exp;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 248: `let chi2_dist = chi2(F::from(df).unwrap(), F::zero(), F::one())?;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 316: `obs_float[(i, j)] = F::from(observed[(i, j)]).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 329: `expected[(i, j)] = row_sums[i] * col_sums[j] / total;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 348: `let diff = (obs - exp).abs() - F::from(0.5).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 354: `chi2_stat = chi2_stat + diff_squared / exp;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 362: `let chi2_dist = chi2(F::from(df).unwrap(), F::zero(), F::one())?;`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/homogeneity.rs

64 issues found:

- Line 100: `n_i.push(F::from(size).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 136: `z_bar = z_bar / n_tot;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 143: `numerator = numerator * (n_tot - F::from(k).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 152: `denominator = denominator * F::from(k - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 155: `let w = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 158: `let df1 = F::from(k - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 159: `let df2 = n_tot - F::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 171: `sum / F::from(data.len()).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 184: `let mid_right = n / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 186: `(sorted[mid_left] + sorted[mid_right]) / F::from(2.0).unwrap()`
  - **Fix**: Use .get() with proper bounds checking
- Line 188: `sorted[n / 2]`
  - **Fix**: Division without zero check - use safe_divide()
- Line 197: `if proportion <= F::zero() || proportion >= F::from(0.5).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 202: `let k = (F::from(n).unwrap() * proportion).floor();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 203: `let k_int = k.to_usize().unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 214: `let f_f64 = <f64 as NumCast>::from(f).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 215: `let df1_f64 = <f64 as NumCast>::from(df1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 216: `let df2_f64 = <f64 as NumCast>::from(df2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 220: `let x = df2_f64 / (df2_f64 + df1_f64 * f_f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 223: `let p = beta_cdf(x, df2_f64 / 2.0, df1_f64 / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 225: `F::from(p).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 244: `if x <= (a / (a + b)) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 246: `bt / beta_function(a, b)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 250: `1.0 - bt / beta_function(b, a)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 261: `let mut d = 1.0 - qab * x / qap;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 265: `d = 1.0 / d;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 272: `let aa = m as f64 * (b - m as f64) * x / ((qam + m2 as f64) * (a + m2 as f64));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 277: `c = 1.0 + aa / c;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 281: `d = 1.0 / d;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 285: `let aa = -(a + m as f64) * (qab + m as f64) * x / ((a + m2 as f64) * (qap + m2 a...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 290: `c = 1.0 + aa / c;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 294: `d = 1.0 / d;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 303: `x.powf(a) * (1.0 - x).powf(b) * h / a`
  - **Fix**: Division without zero check - use safe_divide()
- Line 303: `x.powf(a) * (1.0 - x).powf(b) * h / a`
  - **Fix**: Mathematical operation .powf( without validation
- Line 309: `gamma_function(a) * gamma_function(b) / gamma_function(a + b)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 320: `return std::f64::consts::PI / ((std::f64::consts::PI * x).sin() * gamma_function...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 339: `result += value / (z + (i + 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 345: `2.506628274631 * t.powf(z + 0.5) * (-t).exp() * result`
  - **Fix**: Mathematical operation .powf( without validation
- Line 416: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 420: `let mean = sample.iter().cloned().sum::<F>() / n_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 421: `let variance = sample.iter().map(|&x| (x - mean).powi(2)).sum::<F>() / df;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 430: `let df_tot = n_tot - F::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `let pooled_var = numerator / df_tot;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 442: `ln_term_sum = ln_term_sum + df_i[i] * (v_i[i] / pooled_var).ln();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 442: `ln_term_sum = ln_term_sum + df_i[i] * (v_i[i] / pooled_var).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 446: `+ (F::one() / (F::from(3).unwrap() * F::from(k - 1).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 447: `* (df_i.iter().map(|&df| F::one() / df).sum::<F>() - F::one() / df_tot);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 449: `let test_statistic = (df_tot * pooled_var.ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 453: `.map(|(&df, &v)| df * v.ln())`
  - **Fix**: Mathematical operation .ln() without validation
- Line 455: `/ correction_factor;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 458: `let df_chi2 = F::from(k - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 466: `let x_f64 = <f64 as NumCast>::from(x).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 467: `let df_f64 = <f64 as NumCast>::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `F::from(p_value).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 508: `series_sum / gamma_a`
  - **Fix**: Division without zero check - use safe_divide()
- Line 515: `series_sum / gamma_a`
  - **Fix**: Division without zero check - use safe_divide()
- Line 520: `1.0 - cf / gamma_a`
  - **Fix**: Division without zero check - use safe_divide()
- Line 534: `let mut term = 1.0 / a;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 538: `term *= x / (a + n as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 545: `sum * (-x).exp() * x.powf(a)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 559: `let mut d = 1.0 / b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 567: `d = 1.0 / (b + a_i * d);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 568: `c = b + a_i / c;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 577: `h * (-x).exp() * x.powf(a)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 619: `levene(samples, "median", F::from(0.05).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/homogeneity_tests/bartlett_tests.rs

5 issues found:

- Line 19: `let (statistic, p_value) = bartlett(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 44: `let (_, p_value) = bartlett(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 58: `let (_, p_value) = bartlett(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 72: `let (statistic, _) = bartlett(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 125: `let (statistic, p_value) = bartlett(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/homogeneity_tests/brown_forsythe_tests.rs

6 issues found:

- Line 21: `let (bf_stat, bf_pval) = brown_forsythe(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 22: `let (lev_stat, lev_pval) = levene(&samples, "median", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 37: `let (_statistic, p_value) = brown_forsythe(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 52: `let (_, p_value) = brown_forsythe(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 66: `let (_bf_stat, bf_pval) = brown_forsythe(&samples).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 67: `let (_lev_stat, lev_pval) = levene(&samples, "mean", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/homogeneity_tests/levene_tests.rs

7 issues found:

- Line 20: `let (statistic, p_value) = levene(&samples, "median", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 40: `let (statistic, p_value) = levene(&samples, "mean", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 59: `let (statistic, p_value) = levene(&samples, "trimmed", 0.1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 83: `let (_, p_value) = levene(&samples, "median", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 97: `let (_, p_value) = levene(&samples, "median", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 111: `let (stat1, p1) = levene(&samples, "mean", 0.05).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 112: `let (stat2, p2) = levene(&samples, "trimmed", 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/mod.rs

66 issues found:

- Line 155: `let n_x = F::from(x.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 156: `let n_y = F::from(y.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 169: `/ (n_x + n_y - F::from(2.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 172: `let se = (pooled_var * (F::one() / n_x + F::one() / n_y)).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 172: `let se = (pooled_var * (F::one() / n_x + F::one() / n_y)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 175: `t_stat = (mean_x - mean_y) / se;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 178: `df = n_x + n_y - F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 183: `let var_x_over_n_x = (std_x * std_x) / n_x;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 184: `let var_y_over_n_y = (std_y * std_y) / n_y;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 185: `let se = (var_x_over_n_x + var_y_over_n_y).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 188: `t_stat = (mean_x - mean_y) / se;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 192: `let denominator = (var_x_over_n_x.powi(2) / (n_x - F::one()))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 193: `+ (var_y_over_n_y.powi(2) / (n_y - F::one()));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 195: `df = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 203: `let p_value = F::from(2.0).unwrap() * (F::one() - t_dist.cdf(abs_t));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 344: `data.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 347: `let n = F::from(data.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 354: `let i_f = F::from(i + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 357: `let ecdf = i_f / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 368: `let current_d_minus = tcdf - (i_f - F::one()) / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 395: `let z = ks_stat * n_effective.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 399: `if z < F::from(0.27).unwrap() {`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `- F::from(2.506628275).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 410: `* (F::one() / z - F::from(1.0 / 3.0).unwrap() + F::from(7.0 / 90.0).unwrap() * z...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 411: `- F::from(2.0 / 105.0).unwrap() * z3`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 412: `+ F::from(2.0 / 1575.0).unwrap() * z4`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 413: `- F::from(2.0 / 14175.0).unwrap() * z5`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 414: `+ F::from(2.0 / 467775.0).unwrap() * z6);`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 420: `let two = F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 488: `data.sort_by(|a, b| a.partial_cmp(b).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 491: `let mean = data.iter().cloned().sum::<F>() / F::from(data.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 502: `for i in 0..n / 2 {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 503: `let a_i = F::from(a[i]).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 508: `let w = numerator.powi(2) / ssq;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 531: `let mut coeffs = vec![0.0; n / 2];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 536: `for (i, coef) in coeffs.iter_mut().enumerate().take(n / 2) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 540: `let m = (i_f - 0.375) / (n_f + 0.25);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 544: `let t = (m * m).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 550: `let t = ((1.0 - m) * (1.0 - m)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 559: `let sum_sq = coeffs.iter().map(|&c| c * c).sum::<f64>().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 571: `let n_f = F::from(n as f64).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 572: `let w_f = <f64 as NumCast>::from(w).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 574: `let y = (1.0 - w_f).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 578: `let _gamma = F::from(0.459).unwrap() * n_f.powf(F::from(-2.0).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 579: `- F::from(2.273).unwrap() * n_f.powf(F::from(-1.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 581: `let mu = F::from(-0.0006714).unwrap() * n_f.powf(F::from(3.0).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 582: `+ F::from(0.025054).unwrap() * n_f.powf(F::from(2.0).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 583: `- F::from(0.39978).unwrap() * n_f`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 584: `+ F::from(0.5440).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 586: `let sigma = (F::from(-0.0020322).unwrap() * n_f.powf(F::from(2.0).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 587: `+ F::from(0.1348).unwrap() * n_f`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 588: `+ F::from(0.029184).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 592: `let z = (F::from(y).unwrap() - mu) / sigma;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 595: `let z_f64 = <f64 as NumCast>::from(z).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 600: `let t = 1.0 / (1.0 + 0.2316419 * abs_z);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 605: `F::from(cdf).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 607: `let t = 1.0 / (1.0 + 0.2316419 * z_f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 612: `F::from(1.0 - cdf).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 623: `let n1_f = F::from(n1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 624: `let n2_f = F::from(n2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 627: `let mu_u = n1_f * n2_f / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 630: `let sigma_u = (n1_f * n2_f * (n1_f + n2_f + F::one()) / F::from(12.0).unwrap())....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 633: `let z = (u - mu_u).abs() / sigma_u;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 636: `let z_f64 = <f64 as NumCast>::from(z).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 642: `let t = 1.0 / (1.0 + 0.2316419 * z_f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 650: `let p_value = F::from(2.0 * (1.0 - cdf)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/nonparametric.rs

54 issues found:

- Line 127: `let avg_rank = F::from(i + j).unwrap() / F::from(2.0).unwrap() + F::one();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 154: `let n = F::from(ranked_diffs.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 157: `let w_mean = n * (n + F::one()) / F::from(4.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 158: `let w_sd = (n * (n + F::one()) * (F::from(2.0).unwrap() * n + F::one())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 159: `/ F::from(24.0).unwrap())`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 160: `.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 164: `F::from(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 170: `let z = (w - w_mean + correction_factor) / w_sd;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 173: `let p_value = F::from(2.0).unwrap() * normal_cdf(-z.abs());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 273: `let avg_rank = F::from(i + j).unwrap() / F::from(2.0).unwrap() + F::one();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 292: `let n1_f = F::from(n1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 293: `let n2_f = F::from(n2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 295: `let u1 = rank_sum_x - (n1_f * (n1_f + F::one())) / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 302: `let mean_u = n1_f * n2_f / F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 319: `let t = F::from(j - i + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 327: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 328: `let tie_correction = tie_correction / (n_f.powi(3) - n_f);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 331: `(n1_f * n2_f * (n_f + F::one()) / F::from(12.0).unwrap()) * (F::one() - tie_corr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 332: `let std_dev_u = var_u.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 336: `F::from(0.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 345: `(u + correction - mean_u) / std_dev_u`
  - **Fix**: Division without zero check - use safe_divide()
- Line 347: `(u - correction - mean_u) / std_dev_u`
  - **Fix**: Division without zero check - use safe_divide()
- Line 352: `(u - correction - mean_u) / std_dev_u`
  - **Fix**: Division without zero check - use safe_divide()
- Line 354: `(u + correction - mean_u) / std_dev_u`
  - **Fix**: Division without zero check - use safe_divide()
- Line 359: `(u.abs() - correction - mean_u.abs()) / std_dev_u`
  - **Fix**: Division without zero check - use safe_divide()
- Line 367: `_ => F::from(2.0).unwrap() * normal_cdf(-z.abs()),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 455: `let avg_rank = F::from(i + j).unwrap() / F::from(2.0).unwrap() + F::one();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 473: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 477: `let n_i = F::from(group_sizes[i]).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 478: `h = h + (rank_sum * rank_sum) / n_i;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 481: `h = (F::from(12.0).unwrap() / (n_f * (n_f + F::one()))) * h`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 482: `- F::from(3.0).unwrap() * (n_f + F::one());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 498: `let t = F::from(j - i + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 499: `tie_correction = tie_correction - (t.powi(3) - t) / (n_f.powi(3) - n_f);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 507: `h = h / tie_correction;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 511: `let df = F::from(samples.len() - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 596: `let avg_rank = F::from(rank_idx + tied_idx).unwrap() / F::from(2.0).unwrap() + F...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 620: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 621: `let k_f = F::from(k).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 628: `let chi2 = (F::from(12.0).unwrap() / (n_f * k_f * (k_f + F::one()))) * sum_ranks...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 629: `- F::from(3.0).unwrap() * n_f * (k_f + F::one());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 640: `let x_f64 = <f64 as NumCast>::from(x).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 650: `let t = 1.0 / (1.0 + 0.2316419 * abs_x);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 663: `F::from(cdf).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 668: `let x_f64 = <f64 as NumCast>::from(x).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 669: `let df_f64 = <f64 as NumCast>::from(df).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 686: `z = (x_f64 / df_f64).powf(1.0 / 3.0)`
  - **Fix**: Division without zero check - use safe_divide()
- Line 686: `z = (x_f64 / df_f64).powf(1.0 / 3.0)`
  - **Fix**: Mathematical operation .powf( without validation
- Line 687: `- (1.0 - 2.0 / (9.0 * df_f64)) / (1.0 / (3.0 * df_f64).sqrt());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 687: `- (1.0 - 2.0 / (9.0 * df_f64)) / (1.0 / (3.0 * df_f64).sqrt());`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 690: `z = (x_f64 / df_f64 - 1.0) * (0.5 * df_f64).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 690: `z = (x_f64 / df_f64 - 1.0) * (0.5 * df_f64).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 693: `z = (x_f64 * 0.5).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 699: `F::from(p).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/nonparametric_tests/friedman_tests.rs

4 issues found:

- Line 18: `let (chi2, p_value) = friedman(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 34: `let (chi2, p_value) = friedman(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 59: `let (chi2, p_value) = friedman(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 78: `let (chi2, p_value) = friedman(&data.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/normality.rs

104 issues found:

- Line 78: `let mean = sorted_data.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 81: `let var = sorted_data.iter().map(|&x| (x - mean).powi(2)).sum::<F>() / F::from(n...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 104: `let mean = sorted_data.iter().cloned().sum::<F>() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 111: `for i in 0..n / 2 {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 112: `let coef = F::from(a[i]).unwrap();`
  - **Fix**: Use .get() with proper bounds checking
- Line 117: `let w = numerator.powi(2) / s_squared;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 133: `let mut a = vec![0.0; n / 2];`
  - **Fix**: Division without zero check - use safe_divide()
- Line 154: `let y = (-2.0 * p_adj.ln()).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 154: `let y = (-2.0 * p_adj.ln()).sqrt();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 158: `let x = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 167: `for (i, value) in a.iter_mut().enumerate().take(n / 2) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 170: `let m = (m_idx as f64 - 0.375) / (n as f64 + 0.25);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 194: `let t = 1.0 / (1.0 + p * z);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 195: `1.0 - c * (-z * z / 2.0).exp() * t * (b1 + t * (b2 + t * (b3 + t * (b4 + t * b5)...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 197: `let t = 1.0 / (1.0 - p * z);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 198: `c * (-z * z / 2.0).exp() * t * (b1 + t * (b2 + t * (b3 + t * (b4 + t * b5))))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 210: `mid = (low + high) / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 218: `(low + high) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 221: `for (i, value) in a.iter_mut().enumerate().take(n / 2) {`
  - **Fix**: Division without zero check - use safe_divide()
- Line 223: `let m = (m_idx as f64 - 0.375) / (n as f64 + 0.25);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 229: `let sum_sq = a.iter().map(|&x| x * x).sum::<f64>().sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 240: `let w_f64 = <f64 as NumCast>::from(w).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 246: `let y = (1.0 - w_f64).ln();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 251: `let _gamma = 0.459 * n_f64.powf(-2.0) - 2.273 * n_f64.powf(-1.0);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 253: `-0.0006714 * n_f64.powf(3.0) + 0.025054 * n_f64.powf(2.0) - 0.39978 * n_f64 + 0....`
  - **Fix**: Mathematical operation .powf( without validation
- Line 254: `let sigma = (-0.0020322 * n_f64.powf(2.0) + 0.1348 * n_f64 + 0.029184).exp();`
  - **Fix**: Mathematical operation .powf( without validation
- Line 259: `-0.0005149 * n_f64.powf(3.0) + 0.018340 * n_f64.powf(2.0) - 0.26758 * n_f64 + 0....`
  - **Fix**: Mathematical operation .powf( without validation
- Line 260: `let sigma = (-0.0012444 * n_f64.powf(2.0) + 0.0943 * n_f64 + 0.02937).exp();`
  - **Fix**: Mathematical operation .powf( without validation
- Line 265: `-0.0003333 * n_f64.powf(3.0) + 0.012694 * n_f64.powf(2.0) - 0.22066 * n_f64 + 0....`
  - **Fix**: Mathematical operation .powf( without validation
- Line 266: `let sigma = (-0.0008526 * n_f64.powf(2.0) + 0.0686 * n_f64 + 0.03215).exp();`
  - **Fix**: Mathematical operation .powf( without validation
- Line 271: `let z = (y - mu) / sigma;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 285: `F::from(p).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 300: `let t = 1.0 / (1.0 + 0.2316419 * z.abs());`
  - **Fix**: Division without zero check - use safe_divide()
- Line 306: `let t = 1.0 / (1.0 + 0.2316419 * z);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 373: `let mean = data.sum() / F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 374: `let variance = data.iter().map(|&x| (x - mean).powi(2)).sum::<F>() / F::from(n)....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 382: `let std_dev = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 389: `let z_data: Vec<F> = sorted_data.iter().map(|&x| (x - mean) / std_dev).collect()...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 402: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 409: `let cdf = F::from(approx_normal_cdf(<f64 as NumCast>::from(z).unwrap())).unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 412: `let i_f = F::from(i + 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 415: `let term1 = ((F::from(2.0).unwrap() * i_f - F::one()) / n_f) * cdf.ln();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 417: `((F::from(2.0).unwrap() * (n_f - i_f) + F::one()) / n_f) * (F::one() - cdf).ln()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 427: `* (F::one() + F::from(0.75).unwrap() / n_f + F::from(2.25).unwrap() / (n_f * n_f...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 437: `let a2 = <f64 as NumCast>::from(a_squared).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 453: `F::from(p.clamp(0.0, 1.0)).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 507: `let n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 510: `let mean = x.iter().cloned().sum::<F>() / n_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 513: `let variance = x.iter().map(|&val| (val - mean).powi(2)).sum::<F>() / n_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 521: `let std_dev = variance.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 524: `let m3 = x.iter().map(|&val| (val - mean).powi(3)).sum::<F>() / n_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 525: `let m4 = x.iter().map(|&val| (val - mean).powi(4)).sum::<F>() / n_f;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 528: `let g1 = m3 / std_dev.powi(3);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 529: `let g2 = m4 / std_dev.powi(4) - F::from(3.0).unwrap(); // Excess kurtosis`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 538: `let p_value = F::from(1.0 - chi2_cdf(<f64 as NumCast>::from(k2).unwrap(), 2.0))....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 548: `let _n_f = F::from(n).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 551: `let g1_f64 = <f64 as NumCast>::from(g1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 555: `let beta2 = 3.0 * (n_f64 - 1.0).powi(2) / ((n_f64 - 2.0) * (n_f64 + 1.0) * (n_f6...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 556: `let omega2 = (2.0 * beta2 - 1.0).sqrt() - 1.0;`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 557: `let delta = 1.0 / (omega2.ln()).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 557: `let delta = 1.0 / (omega2.ln()).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 557: `let delta = 1.0 / (omega2.ln()).sqrt();`
  - **Fix**: Mathematical operation .ln() without validation
- Line 558: `let alpha = (2.0 / (omega2 - 1.0)).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 558: `let alpha = (2.0 / (omega2 - 1.0)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 560: `let y = g1_f64 * ((n_f64 + 1.0) * (n_f64 + 3.0) / (6.0 * (n_f64 - 2.0))).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 560: `let y = g1_f64 * ((n_f64 + 1.0) * (n_f64 + 3.0) / (6.0 * (n_f64 - 2.0))).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 561: `let z1 = delta * (y / alpha).asinh();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 564: `let g2_f64 = <f64 as NumCast>::from(g2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 567: `let mean_g2 = 6.0 / (n_f64 + 1.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 569: `/ ((n_f64 + 1.0).powi(2) * (n_f64 + 3.0) * (n_f64 + 5.0));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 570: `let std_g2 = var_g2.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 572: `let a = 6.0 + 8.0 / std_g2 * (2.0 / std_g2 + (1.0 + 4.0 / std_g2.powi(2)).sqrt()...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 572: `let a = 6.0 + 8.0 / std_g2 * (2.0 / std_g2 + (1.0 + 4.0 / std_g2.powi(2)).sqrt()...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 573: `let z2 = ((1.0 - 2.0 / a) * (1.0 + (g2_f64 - mean_g2) / std_g2 * (2.0 / (a - 4.0...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 573: `let z2 = ((1.0 - 2.0 / a) * (1.0 + (g2_f64 - mean_g2) / std_g2 * (2.0 / (a - 4.0...`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 574: `.powf(1.0 / 3.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 574: `.powf(1.0 / 3.0);`
  - **Fix**: Mathematical operation .powf( without validation
- Line 575: `let z2 = (a - 2.0) / 2.0 * (z2 - 1.0 / z2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 577: `Ok((F::from(z1).unwrap(), F::from(z2).unwrap()))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 588: `let gamma_incomplete = lower_gamma_incomplete(df / 2.0, x / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 589: `let gamma_complete = gamma_function(df / 2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 591: `gamma_incomplete / gamma_complete`
  - **Fix**: Division without zero check - use safe_divide()
- Line 603: `let mut term = 1.0 / s;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 608: `term *= x / (s + n);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 617: `return x.powf(s) * (-x).exp() * sum;`
  - **Fix**: Mathematical operation .powf( without validation
- Line 623: `let step = x / N_STEPS as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 630: `let y1 = t1.powf(s - 1.0) * (-t1).exp();`
  - **Fix**: Mathematical operation .powf( without validation
- Line 631: `let y2 = t2.powf(s - 1.0) * (-t2).exp();`
  - **Fix**: Mathematical operation .powf( without validation
- Line 633: `sum += (y1 + y2) * step / 2.0;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 647: `return std::f64::consts::PI / ((std::f64::consts::PI * x).sin() * gamma_function...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 666: `result += p_val / (z + (i + 1) as f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 671: `(2.0 * std::f64::consts::PI).sqrt() * t.powf(z + 0.5) * (-t).exp() * result`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 671: `(2.0 * std::f64::consts::PI).sqrt() * t.powf(z + 0.5) * (-t).exp() * result`
  - **Fix**: Mathematical operation .powf( without validation
- Line 738: `let n1_f = F::from(n1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 739: `let n2_f = F::from(n2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 760: `ecdf_x.push((val, F::from(i + 1).unwrap() / n1_f));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 763: `ecdf_y.push((val, F::from(i + 1).unwrap() / n2_f));`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 790: `fx = F::from(ix + 1).unwrap() / n1_f;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 796: `fy = F::from(iy + 1).unwrap() / n2_f;`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 846: `let d_f64 = <f64 as NumCast>::from(d).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 851: `let n = (n1_f64 * n2_f64) / (n1_f64 + n2_f64);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 852: `let z = d_f64 * (n * 0.5).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 866: `1.0 - 2.506628275 * (z - (z_cb / 3.0) + (7.0 * z_5 / 90.0) - (z_6 / 42.0)).exp()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 881: `F::from(p.clamp(0.0, 1.0)).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/normality_tests.rs

6 issues found:

- Line 14: `let (stat, p_value) = ks_2samp(&x.view(), &y.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 28: `let (stat, p_value) = ks_2samp(&x.view(), &y.view(), "two-sided").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 44: `let (_stat, _p_value_less) = ks_2samp(&x.view(), &y.view(), "less").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 47: `let (_stat, _p_value_greater) = ks_2samp(&x.view(), &y.view(), "greater").unwrap...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 61: `let (_stat, p_value_greater) = ks_2samp(&x.view(), &y.view(), "greater").unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 64: `let (_stat, p_value_less) = ks_2samp(&x.view(), &y.view(), "less").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/tests/ttest.rs

55 issues found:

- Line 126: `let n = F::from(data.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 127: `let se = sample_std / n.sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 127: `let se = sample_std / n.sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 130: `let t_stat = (sample_mean - popmean) / se;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 133: `let df = F::from(data.len() - 1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 142: `F::from(2.0).unwrap() * (F::one() - t_dist.cdf(abs_t))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 244: `let n_a = F::from(data_a.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 245: `let n_b = F::from(data_b.len()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 262: `/ (n_a + n_b - F::from(2.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 265: `let se = (pooled_var * (F::one() / n_a + F::one() / n_b)).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 265: `let se = (pooled_var * (F::one() / n_a + F::one() / n_b)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 268: `t_stat = (mean_a - mean_b) / se;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 271: `df = n_a + n_b - F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 278: `let var_a_over_n_a = variance_a / n_a;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 279: `let var_b_over_n_b = variance_b / n_b;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 280: `let se = (var_a_over_n_a + var_b_over_n_b).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 283: `t_stat = (mean_a - mean_b) / se;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 287: `let denominator = (var_a_over_n_a.powi(2) / (n_a - F::one()))`
  - **Fix**: Division without zero check - use safe_divide()
- Line 288: `+ (var_b_over_n_b.powi(2) / (n_b - F::one()));`
  - **Fix**: Division without zero check - use safe_divide()
- Line 290: `df = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 302: `F::from(2.0).unwrap() * (F::one() - t_dist.cdf(abs_t))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 449: `valid_a.iter().cloned().sum::<F>() / F::from(valid_a.len()).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 455: `valid_b.iter().cloned().sum::<F>() / F::from(valid_b.len()).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 546: `let n1 = F::from(nobs1).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 547: `let n2 = F::from(nobs2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 560: `/ (n1 + n2 - F::from(2.0).unwrap());`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 563: `let se = (pooled_var * (F::one() / n1 + F::one() / n2)).sqrt();`
  - **Fix**: Division without zero check - use safe_divide()
- Line 563: `let se = (pooled_var * (F::one() / n1 + F::one() / n2)).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 566: `t_stat = (mean1 - mean2) / se;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 569: `df = n1 + n2 - F::from(2.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 576: `let var1_over_n1 = variance1 / n1;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 577: `let var2_over_n2 = variance2 / n2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 578: `let se = (var1_over_n1 + var2_over_n2).sqrt();`
  - **Fix**: Mathematical operation .sqrt() without validation
- Line 581: `t_stat = (mean1 - mean2) / se;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 586: `(var1_over_n1.powi(2) / (n1 - F::one())) + (var2_over_n2.powi(2) / (n2 - F::one(...`
  - **Fix**: Division without zero check - use safe_divide()
- Line 588: `df = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 600: `F::from(2.0).unwrap() * (F::one() - t_dist.cdf(abs_t))`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 630: `F::from(5.1).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 631: `F::from(4.9).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 632: `F::from(6.2).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 633: `F::from(5.7).unwrap(),`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 634: `F::from(5.5).unwrap()`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 646: `let result = ttest_1samp(&data.view(), null_mean, Alternative::TwoSided, "omit")...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 652: `let result = ttest_1samp(&data.view(), null_mean, Alternative::Greater, "omit")....`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 658: `let result = ttest_1samp(&data.view(), null_mean, Alternative::Less, "omit").unw...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 669: `let result = ttest_1samp(&data.view(), null_mean, Alternative::TwoSided, "omit")...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 679: `ttest_1samp(&data.view(), null_mean, Alternative::TwoSided, "propagate").unwrap(...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 696: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 709: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 722: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 741: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 763: `ttest_rel(&before.view(), &after.view(), Alternative::TwoSided, "omit").unwrap()...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 769: `ttest_rel(&before.view(), &after.view(), Alternative::Greater, "omit").unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 774: `let result = ttest_rel(&before.view(), &after.view(), Alternative::Less, "omit")...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 799: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### src/traits/distribution.rs

4 issues found:

- Line 57: `self.pdf(x) / survival`
  - **Fix**: Division without zero check - use safe_divide()
- Line 63: `-self.sf(x).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 127: `self.pmf(x).ln()`
  - **Fix**: Mathematical operation .ln() without validation
- Line 138: `self.pdf(x).ln()`
  - **Fix**: Mathematical operation .ln() without validation

### tests/regression_integration.rs

26 issues found:

- Line 16: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 22: `let results = linear_regression(&x.view(), &y.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 38: `let result = polyfit(&x.view(), &y.view(), 2).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 55: `let result = theilslopes(&x.view(), &y.view(), None, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 73: `let result = ransac(&x.view(), &y.view(), None, None, None, None, Some(42)).unwr...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 121: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 133: `let x_new = Array2::from_shape_vec((3, 2), vec![1.0, 5.0, 1.0, 10.0, 1.0, 15.0])...`
  - **Fix**: Handle array creation errors properly
- Line 134: `let predictions = result.predict(&x_new.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 153: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 179: `let result = ransac(&x_col1.view(), &y.view(), None, None, None, None, Some(42))...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 201: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 206: `huber_regression(&x.view(), &y.view(), None, None, None, None, None, None).unwra...`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 225: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 264: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 280: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 300: `let base = i as f64 / 5.0 + rng.random_range(0.0..2.0);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 347: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 360: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 390: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 394: `let model = linear_regression(&x.view(), &y.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 416: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 420: `let model = linear_regression(&x.view(), &y.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 430: `.unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 432: `let predictions = model.predict(&x_new.view()).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 452: `let ols = linear_regression(&x_design.view(), &y.view(), None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 455: `let theil = theilslopes(&x.view(), &y.view(), None, None).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()

### tests/sampling_integration.rs

14 issues found:

- Line 12: `let normal = norm(0.0f64, 1.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 15: `let samples1 = sampling::sample_distribution(&normal, 100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 16: `let samples2 = normal.rvs(100).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 22: `let samples_seeded1 = random::randn(20, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 23: `let samples_seeded2 = random::randn(20, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 37: `let samples = sampling::bootstrap(&data.view(), 100, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 64: `let perm = sampling::permutation(&data.view(), Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 85: `let uniform_samples = random::uniform(0.0, 1.0, 10000, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 95: `let normal_samples = random::randn(10000, Some(42)).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 105: `let poisson_dist = poisson(3.0f64, 0.0).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 106: `let samples = poisson_dist.rvs(10000).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 120: `sum / arr.len() as f64`
  - **Fix**: Division without zero check - use safe_divide()
- Line 131: `(sum_sq / denominator).sqrt()`
  - **Fix**: Division without zero check - use safe_divide()
- Line 131: `(sum_sq / denominator).sqrt()`
  - **Fix**: Mathematical operation .sqrt() without validation

### tests/test_robust_regression.rs

10 issues found:

- Line 22: `let mut slopes = Vec::with_capacity(n * (n - 1) / 2);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 30: `slopes.push(dy / dx);`
  - **Fix**: Division without zero check - use safe_divide()
- Line 39: `let mid = slopes.len() / 2;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 41: `(slopes[mid - 1] + slopes[mid]) / 2.0`
  - **Fix**: Division without zero check - use safe_divide()
- Line 49: `let x_median = x.iter().sum::<f64>() / n as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 50: `let y_median = y.iter().sum::<f64>() / n as f64;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 63: `let theil = simple_theilslopes(&x, &y).unwrap();`
  - **Fix**: Replace with ? operator or .ok_or()
- Line 71: `let x_mean = x.iter().sum::<f64>() / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 72: `let y_mean = y.iter().sum::<f64>() / n;`
  - **Fix**: Division without zero check - use safe_divide()
- Line 84: `let ols_slope = numerator / denominator;`
  - **Fix**: Division without zero check - use safe_divide()